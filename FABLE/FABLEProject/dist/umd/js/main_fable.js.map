{"version":3,"file":"main_fable.js","sources":["../../../src/js/helper_functions.js","../../../node_modules/fable-core/Symbol.js","../../../node_modules/fable-core/Util.js","../../../node_modules/fable-core/ListClass.js","../../../node_modules/fable-core/GenericComparer.js","../../../node_modules/fable-core/Seq.js","../../../node_modules/fable-core/Map.js","../../../node_modules/fable-core/List.js","../../../src/fs/State.fs","../../../node_modules/fable-core/RegExp.js","../../../node_modules/fable-core/Long.js","../../../node_modules/fable-core/Date.js","../../../node_modules/fable-core/String.js","../../../src/fs/FsHtml.fs","../../../src/fs/Error.fs","../../../src/fs/Interpreter.fs","../../../src/fs/ParseError.fs","../../../src/fs/Types.fs","../../../src/fs/ARMv4.fs","../../../src/fs/Parser.fs","../../../src/fs/Conditions.fs","../../../src/fs/Tokeniser.fs","../../../src/fs/GetStates.fs","../../../node_modules/fable-core/Set.js","../../../node_modules/fable-core/Reflection.js","../../../node_modules/fable-core/Serialize.js","../../../src/fs/JSTest.fs","../../../src/fs/Main.fs"],"sourcesContent":["export function saveCodeMirror(myEditor)\n{\n\tmyEditor.save();\n\treturn document.getElementById(\"editor\").value;\n}\n\nexport function initializeCodeMirror() {\n\tvar editor = CodeMirror.fromTextArea(document.getElementById(\"editor\"), {\n\t\t\tlineNumbers: true,\n\t\t\ttheme: 'blackboard'\n\t\t});\n\treturn editor\n}\n\nexport function changeCMTheme(cmEditor) {\n\t//console.log(\"changeCMTheme\")\n\t//myEditor.refresh();\n}\n\nexport function highlightLine(lineNumber,myEditor,colour) {\n\tvar actualLine = lineNumber - 1\n\tif(colour == 1) {\n\t\tvar actualLine = lineNumber - 1\n\t\tmyEditor.addLineClass(actualLine, 'background', 'error');\n\t}\n\tif(colour == 2) {\n\t\tvar actualLine = lineNumber - 1\n\t\tmyEditor.addLineClass(actualLine, 'background', 'select');\n\t}\n\tmyEditor.refresh();\n}\n\nexport function clearAllLines(myEditor) {\n\tfor (var i = 0; i < myEditor.lineCount(); i++) {\n\t\tmyEditor.removeLineClass(i, 'background', 'error');\n\t\tmyEditor.removeLineClass(i, 'background', 'select')\n\t}\n\tmyEditor.refresh();\n}\n\nexport function getJSON() {\n\tconst FS = require('fs');\n\tvar testsString = FS.readFileSync(\"./tests.json\", 'utf8');\n\treturn testsString;\n}\n","var fableGlobal = function () {\r\n    var globalObj = typeof window !== \"undefined\" ? window\r\n        : (typeof global !== \"undefined\" ? global\r\n            : (typeof self !== \"undefined\" ? self : {}));\r\n    if (typeof globalObj.__FABLE_CORE__ === \"undefined\") {\r\n        globalObj.__FABLE_CORE__ = {\r\n            types: new Map(),\r\n            symbols: {\r\n                reflection: Symbol(\"reflection\"),\r\n            }\r\n        };\r\n    }\r\n    return globalObj.__FABLE_CORE__;\r\n}();\r\nexport function setType(fullName, cons) {\r\n    fableGlobal.types.set(fullName, cons);\r\n}\r\nexport function getType(fullName) {\r\n    return fableGlobal.types.get(fullName);\r\n}\r\nexport default (fableGlobal.symbols);\r\n","import FSymbol from \"./Symbol\";\r\nvar NonDeclaredType = (function () {\r\n    function NonDeclaredType(kind, definition, generics) {\r\n        this.kind = kind;\r\n        this.definition = definition;\r\n        this.generics = generics;\r\n    }\r\n    NonDeclaredType.prototype.Equals = function (other) {\r\n        if (this.kind === other.kind && this.definition === other.definition) {\r\n            return typeof this.generics === \"object\"\r\n                ? equalsRecords(this.generics, other.generics)\r\n                : this.generics === other.generics;\r\n        }\r\n        return false;\r\n    };\r\n    return NonDeclaredType;\r\n}());\r\nexport { NonDeclaredType };\r\nexport var Any = new NonDeclaredType(\"Any\");\r\nexport var Unit = new NonDeclaredType(\"Unit\");\r\nexport function Option(t) {\r\n    return new NonDeclaredType(\"Option\", null, t);\r\n}\r\nfunction FableArray(t, isTypedArray) {\r\n    if (isTypedArray === void 0) { isTypedArray = false; }\r\n    var def = null, genArg = null;\r\n    if (isTypedArray) {\r\n        def = t;\r\n    }\r\n    else {\r\n        genArg = t;\r\n    }\r\n    return new NonDeclaredType(\"Array\", def, genArg);\r\n}\r\nexport { FableArray as Array };\r\nexport function Tuple(ts) {\r\n    return new NonDeclaredType(\"Tuple\", null, ts);\r\n}\r\nexport function GenericParam(definition) {\r\n    return new NonDeclaredType(\"GenericParam\", definition);\r\n}\r\nexport function Interface(definition) {\r\n    return new NonDeclaredType(\"Interface\", definition);\r\n}\r\nexport function makeGeneric(typeDef, genArgs) {\r\n    return new NonDeclaredType(\"GenericType\", typeDef, genArgs);\r\n}\r\nexport function isGeneric(typ) {\r\n    return typ instanceof NonDeclaredType && typ.kind === \"GenericType\";\r\n}\r\nexport function getDefinition(typ) {\r\n    return isGeneric(typ) ? typ.definition : typ;\r\n}\r\nexport function extendInfo(cons, info) {\r\n    var parent = Object.getPrototypeOf(cons.prototype);\r\n    if (typeof parent[FSymbol.reflection] === \"function\") {\r\n        var newInfo_1 = {}, parentInfo_1 = parent[FSymbol.reflection]();\r\n        Object.getOwnPropertyNames(info).forEach(function (k) {\r\n            var i = info[k];\r\n            if (typeof i === \"object\") {\r\n                newInfo_1[k] = Array.isArray(i)\r\n                    ? (parentInfo_1[k] || []).concat(i)\r\n                    : Object.assign(parentInfo_1[k] || {}, i);\r\n            }\r\n            else {\r\n                newInfo_1[k] = i;\r\n            }\r\n        });\r\n        return newInfo_1;\r\n    }\r\n    return info;\r\n}\r\nexport function hasInterface(obj, interfaceName) {\r\n    if (interfaceName === \"System.Collections.Generic.IEnumerable\") {\r\n        return typeof obj[Symbol.iterator] === \"function\";\r\n    }\r\n    else if (typeof obj[FSymbol.reflection] === \"function\") {\r\n        var interfaces = obj[FSymbol.reflection]().interfaces;\r\n        return Array.isArray(interfaces) && interfaces.indexOf(interfaceName) > -1;\r\n    }\r\n    return false;\r\n}\r\nexport function getPropertyNames(obj) {\r\n    if (obj == null) {\r\n        return [];\r\n    }\r\n    var propertyMap = typeof obj[FSymbol.reflection] === \"function\" ? obj[FSymbol.reflection]().properties || [] : obj;\r\n    return Object.getOwnPropertyNames(propertyMap);\r\n}\r\nexport function isArray(obj) {\r\n    return Array.isArray(obj) || ArrayBuffer.isView(obj);\r\n}\r\nexport function getRestParams(args, idx) {\r\n    for (var _len = args.length, restArgs = Array(_len > idx ? _len - idx : 0), _key = idx; _key < _len; _key++)\r\n        restArgs[_key - idx] = args[_key];\r\n    return restArgs;\r\n}\r\nexport function toString(o) {\r\n    return o != null && typeof o.ToString == \"function\" ? o.ToString() : String(o);\r\n}\r\nexport function hash(x) {\r\n    var s = JSON.stringify(x);\r\n    var h = 5381, i = 0, len = s.length;\r\n    while (i < len) {\r\n        h = (h * 33) ^ s.charCodeAt(i++);\r\n    }\r\n    return h;\r\n}\r\nexport function equals(x, y) {\r\n    if (x === y)\r\n        return true;\r\n    else if (x == null)\r\n        return y == null;\r\n    else if (y == null)\r\n        return false;\r\n    else if (Object.getPrototypeOf(x) !== Object.getPrototypeOf(y))\r\n        return false;\r\n    else if (typeof x.Equals === \"function\")\r\n        return x.Equals(y);\r\n    else if (Array.isArray(x)) {\r\n        if (x.length != y.length)\r\n            return false;\r\n        for (var i = 0; i < x.length; i++)\r\n            if (!equals(x[i], y[i]))\r\n                return false;\r\n        return true;\r\n    }\r\n    else if (ArrayBuffer.isView(x)) {\r\n        if (x.byteLength !== y.byteLength)\r\n            return false;\r\n        var dv1 = new DataView(x.buffer), dv2 = new DataView(y.buffer);\r\n        for (var i = 0; i < x.byteLength; i++)\r\n            if (dv1.getUint8(i) !== dv2.getUint8(i))\r\n                return false;\r\n        return true;\r\n    }\r\n    else if (x instanceof Date)\r\n        return x.getTime() == y.getTime();\r\n    else\r\n        return false;\r\n}\r\nexport function compare(x, y) {\r\n    if (x === y)\r\n        return 0;\r\n    if (x == null)\r\n        return y == null ? 0 : -1;\r\n    else if (y == null)\r\n        return 1;\r\n    else if (Object.getPrototypeOf(x) !== Object.getPrototypeOf(y))\r\n        return -1;\r\n    else if (typeof x.CompareTo === \"function\")\r\n        return x.CompareTo(y);\r\n    else if (Array.isArray(x)) {\r\n        if (x.length != y.length)\r\n            return x.length < y.length ? -1 : 1;\r\n        for (var i = 0, j = 0; i < x.length; i++)\r\n            if ((j = compare(x[i], y[i])) !== 0)\r\n                return j;\r\n        return 0;\r\n    }\r\n    else if (ArrayBuffer.isView(x)) {\r\n        if (x.byteLength != y.byteLength)\r\n            return x.byteLength < y.byteLength ? -1 : 1;\r\n        var dv1 = new DataView(x.buffer), dv2 = new DataView(y.buffer);\r\n        for (var i = 0, b1 = 0, b2 = 0; i < x.byteLength; i++) {\r\n            b1 = dv1.getUint8(i), b2 = dv2.getUint8(i);\r\n            if (b1 < b2)\r\n                return -1;\r\n            if (b1 > b2)\r\n                return 1;\r\n        }\r\n        return 0;\r\n    }\r\n    else if (x instanceof Date)\r\n        return compare(x.getTime(), y.getTime());\r\n    else\r\n        return x < y ? -1 : 1;\r\n}\r\nexport function equalsRecords(x, y) {\r\n    if (x === y) {\r\n        return true;\r\n    }\r\n    else {\r\n        var keys = getPropertyNames(x);\r\n        for (var i = 0; i < keys.length; i++) {\r\n            if (!equals(x[keys[i]], y[keys[i]]))\r\n                return false;\r\n        }\r\n        return true;\r\n    }\r\n}\r\nexport function compareRecords(x, y) {\r\n    if (x === y) {\r\n        return 0;\r\n    }\r\n    else {\r\n        var keys = getPropertyNames(x);\r\n        for (var i = 0; i < keys.length; i++) {\r\n            var res = compare(x[keys[i]], y[keys[i]]);\r\n            if (res !== 0)\r\n                return res;\r\n        }\r\n        return 0;\r\n    }\r\n}\r\nexport function equalsUnions(x, y) {\r\n    if (x === y) {\r\n        return true;\r\n    }\r\n    else if (x.Case !== y.Case) {\r\n        return false;\r\n    }\r\n    else {\r\n        for (var i = 0; i < x.Fields.length; i++) {\r\n            if (!equals(x.Fields[i], y.Fields[i]))\r\n                return false;\r\n        }\r\n        return true;\r\n    }\r\n}\r\nexport function compareUnions(x, y) {\r\n    if (x === y) {\r\n        return 0;\r\n    }\r\n    else {\r\n        var res = compare(x.Case, y.Case);\r\n        if (res !== 0)\r\n            return res;\r\n        for (var i = 0; i < x.Fields.length; i++) {\r\n            res = compare(x.Fields[i], y.Fields[i]);\r\n            if (res !== 0)\r\n                return res;\r\n        }\r\n        return 0;\r\n    }\r\n}\r\nexport function createDisposable(f) {\r\n    return _a = {\r\n            Dispose: f\r\n        },\r\n        _a[FSymbol.reflection] = function () { return { interfaces: [\"System.IDisposable\"] }; },\r\n        _a;\r\n    var _a;\r\n}\r\nexport function createObj(fields) {\r\n    var iter = fields[Symbol.iterator]();\r\n    var cur = iter.next(), o = {};\r\n    while (!cur.done) {\r\n        o[cur.value[0]] = cur.value[1];\r\n        cur = iter.next();\r\n    }\r\n    return o;\r\n}\r\nexport function toPlainJsObj(source) {\r\n    if (source != null && source.constructor != Object) {\r\n        var target = {};\r\n        var props = Object.getOwnPropertyNames(source);\r\n        for (var i = 0; i < props.length; i++) {\r\n            target[props[i]] = source[props[i]];\r\n        }\r\n        var proto = Object.getPrototypeOf(source);\r\n        if (proto != null) {\r\n            props = Object.getOwnPropertyNames(proto);\r\n            for (var i = 0; i < props.length; i++) {\r\n                var prop = Object.getOwnPropertyDescriptor(proto, props[i]);\r\n                if (prop.value) {\r\n                    target[props[i]] = prop.value;\r\n                }\r\n                else if (prop.get) {\r\n                    target[props[i]] = prop.get.apply(source);\r\n                }\r\n            }\r\n        }\r\n        return target;\r\n    }\r\n    else {\r\n        return source;\r\n    }\r\n}\r\nexport function round(value, digits) {\r\n    if (digits === void 0) { digits = 0; }\r\n    var m = Math.pow(10, digits);\r\n    var n = +(digits ? value * m : value).toFixed(8);\r\n    var i = Math.floor(n), f = n - i;\r\n    var e = 1e-8;\r\n    var r = (f > 0.5 - e && f < 0.5 + e) ? ((i % 2 == 0) ? i : i + 1) : Math.round(n);\r\n    return digits ? r / m : r;\r\n}\r\nexport function randomNext(min, max) {\r\n    return Math.floor(Math.random() * (max - min)) + min;\r\n}\r\nexport function defaultArg(arg, defaultValue, f) {\r\n    return arg == null ? defaultValue : (f != null ? f(arg) : arg);\r\n}\r\n","import FSymbol from \"./Symbol\";\r\nimport { toString } from \"./Util\";\r\nimport { equals } from \"./Util\";\r\nimport { compare } from \"./Util\";\r\nexport function ofArray(args, base) {\r\n    var acc = base || new List();\r\n    for (var i = args.length - 1; i >= 0; i--) {\r\n        acc = new List(args[i], acc);\r\n    }\r\n    return acc;\r\n}\r\nvar List = (function () {\r\n    function List(head, tail) {\r\n        this.head = head;\r\n        this.tail = tail;\r\n    }\r\n    List.prototype.ToString = function () {\r\n        return \"[\" + Array.from(this).map(toString).join(\"; \") + \"]\";\r\n    };\r\n    List.prototype.Equals = function (x) {\r\n        if (this === x) {\r\n            return true;\r\n        }\r\n        else {\r\n            var iter1 = this[Symbol.iterator](), iter2 = x[Symbol.iterator]();\r\n            for (;;) {\r\n                var cur1 = iter1.next(), cur2 = iter2.next();\r\n                if (cur1.done)\r\n                    return cur2.done ? true : false;\r\n                else if (cur2.done)\r\n                    return false;\r\n                else if (!equals(cur1.value, cur2.value))\r\n                    return false;\r\n            }\r\n        }\r\n    };\r\n    List.prototype.CompareTo = function (x) {\r\n        if (this === x) {\r\n            return 0;\r\n        }\r\n        else {\r\n            var acc = 0;\r\n            var iter1 = this[Symbol.iterator](), iter2 = x[Symbol.iterator]();\r\n            for (;;) {\r\n                var cur1 = iter1.next(), cur2 = iter2.next();\r\n                if (cur1.done)\r\n                    return cur2.done ? acc : -1;\r\n                else if (cur2.done)\r\n                    return 1;\r\n                else {\r\n                    acc = compare(cur1.value, cur2.value);\r\n                    if (acc != 0)\r\n                        return acc;\r\n                }\r\n            }\r\n        }\r\n    };\r\n    Object.defineProperty(List.prototype, \"length\", {\r\n        get: function () {\r\n            var cur = this, acc = 0;\r\n            while (cur.tail != null) {\r\n                cur = cur.tail;\r\n                acc++;\r\n            }\r\n            return acc;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    List.prototype[Symbol.iterator] = function () {\r\n        var cur = this;\r\n        return {\r\n            next: function () {\r\n                var tmp = cur;\r\n                cur = cur.tail;\r\n                return { done: tmp.tail == null, value: tmp.head };\r\n            }\r\n        };\r\n    };\r\n    List.prototype[FSymbol.reflection] = function () {\r\n        return {\r\n            type: \"Microsoft.FSharp.Collections.FSharpList\",\r\n            interfaces: [\"System.IEquatable\", \"System.IComparable\"]\r\n        };\r\n    };\r\n    return List;\r\n}());\r\nexport default List;\r\n","import { compare } from \"./Util\";\r\nimport FSymbol from \"./Symbol\";\r\nvar GenericComparer = (function () {\r\n    function GenericComparer(f) {\r\n        this.Compare = f || compare;\r\n    }\r\n    GenericComparer.prototype[FSymbol.reflection] = function () {\r\n        return { interfaces: [\"System.IComparer\"] };\r\n    };\r\n    return GenericComparer;\r\n}());\r\nexport default GenericComparer;\r\n","import { equals } from \"./Util\";\r\nimport { compare } from \"./Util\";\r\nimport { permute as arrayPermute } from \"./Array\";\r\nimport List from \"./ListClass\";\r\nvar Enumerator = (function () {\r\n    function Enumerator(iter) {\r\n        this.iter = iter;\r\n    }\r\n    Enumerator.prototype.MoveNext = function () {\r\n        var cur = this.iter.next();\r\n        this.current = cur.value;\r\n        return !cur.done;\r\n    };\r\n    Object.defineProperty(Enumerator.prototype, \"Current\", {\r\n        get: function () {\r\n            return this.current;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Enumerator.prototype.Reset = function () {\r\n        throw new Error(\"JS iterators cannot be reset\");\r\n    };\r\n    Enumerator.prototype.Dispose = function () { };\r\n    return Enumerator;\r\n}());\r\nexport { Enumerator };\r\nexport function getEnumerator(o) {\r\n    return typeof o.GetEnumerator === \"function\"\r\n        ? o.GetEnumerator() : new Enumerator(o[Symbol.iterator]());\r\n}\r\nexport function toIterator(en) {\r\n    return {\r\n        next: function () {\r\n            return en.MoveNext()\r\n                ? { done: false, value: en.Current }\r\n                : { done: true, value: null };\r\n        }\r\n    };\r\n}\r\nfunction __failIfNone(res) {\r\n    if (res == null)\r\n        throw new Error(\"Seq did not contain any matching element\");\r\n    return res;\r\n}\r\nexport function toList(xs) {\r\n    return foldBack(function (x, acc) {\r\n        return new List(x, acc);\r\n    }, xs, new List());\r\n}\r\nexport function ofList(xs) {\r\n    return delay(function () { return unfold(function (x) { return x.tail != null ? [x.head, x.tail] : null; }, xs); });\r\n}\r\nexport function ofArray(xs) {\r\n    return delay(function () { return unfold(function (i) { return i < xs.length ? [xs[i], i + 1] : null; }, 0); });\r\n}\r\nexport function append(xs, ys) {\r\n    return delay(function () {\r\n        var firstDone = false;\r\n        var i = xs[Symbol.iterator]();\r\n        var iters = [i, null];\r\n        return unfold(function () {\r\n            var cur;\r\n            if (!firstDone) {\r\n                cur = iters[0].next();\r\n                if (!cur.done) {\r\n                    return [cur.value, iters];\r\n                }\r\n                else {\r\n                    firstDone = true;\r\n                    iters = [null, ys[Symbol.iterator]()];\r\n                }\r\n            }\r\n            cur = iters[1].next();\r\n            return !cur.done ? [cur.value, iters] : null;\r\n        }, iters);\r\n    });\r\n}\r\nexport function average(xs) {\r\n    var count = 1;\r\n    var sum = reduce(function (acc, x) {\r\n        count++;\r\n        return acc + x;\r\n    }, xs);\r\n    return sum / count;\r\n}\r\nexport function averageBy(f, xs) {\r\n    var count = 1;\r\n    var sum = reduce(function (acc, x) {\r\n        count++;\r\n        return (count === 2 ? f(acc) : acc) + f(x);\r\n    }, xs);\r\n    return sum / count;\r\n}\r\nexport function concat(xs) {\r\n    return delay(function () {\r\n        var iter = xs[Symbol.iterator]();\r\n        var output = { value: null };\r\n        return unfold(function (innerIter) {\r\n            var hasFinished = false;\r\n            while (!hasFinished) {\r\n                if (innerIter == null) {\r\n                    var cur = iter.next();\r\n                    if (!cur.done) {\r\n                        innerIter = cur.value[Symbol.iterator]();\r\n                    }\r\n                    else {\r\n                        hasFinished = true;\r\n                    }\r\n                }\r\n                else {\r\n                    var cur = innerIter.next();\r\n                    if (!cur.done) {\r\n                        output = { value: cur.value };\r\n                        hasFinished = true;\r\n                    }\r\n                    else {\r\n                        innerIter = null;\r\n                    }\r\n                }\r\n            }\r\n            return innerIter != null && output != null ? [output.value, innerIter] : null;\r\n        }, null);\r\n    });\r\n}\r\nexport function collect(f, xs) {\r\n    return concat(map(f, xs));\r\n}\r\nexport function choose(f, xs) {\r\n    var trySkipToNext = function (iter) {\r\n        var cur = iter.next();\r\n        if (!cur.done) {\r\n            var y = f(cur.value);\r\n            return y != null ? [y, iter] : trySkipToNext(iter);\r\n        }\r\n        return void 0;\r\n    };\r\n    return delay(function () {\r\n        return unfold(function (iter) {\r\n            return trySkipToNext(iter);\r\n        }, xs[Symbol.iterator]());\r\n    });\r\n}\r\nexport function compareWith(f, xs, ys) {\r\n    var nonZero = tryFind(function (i) { return i != 0; }, map2(function (x, y) { return f(x, y); }, xs, ys));\r\n    return nonZero != null ? nonZero : count(xs) - count(ys);\r\n}\r\nexport function delay(f) {\r\n    return _a = {},\r\n        _a[Symbol.iterator] = function () { return f()[Symbol.iterator](); },\r\n        _a;\r\n    var _a;\r\n}\r\nexport function empty() {\r\n    return unfold(function () { return void 0; });\r\n}\r\nexport function enumerateWhile(cond, xs) {\r\n    return concat(unfold(function () { return cond() ? [xs, true] : null; }));\r\n}\r\nexport function enumerateThenFinally(xs, finalFn) {\r\n    return delay(function () {\r\n        var iter;\r\n        try {\r\n            iter = xs[Symbol.iterator]();\r\n        }\r\n        catch (err) {\r\n            return void 0;\r\n        }\r\n        finally {\r\n            finalFn();\r\n        }\r\n        return unfold(function (iter) {\r\n            try {\r\n                var cur = iter.next();\r\n                return !cur.done ? [cur.value, iter] : null;\r\n            }\r\n            catch (err) {\r\n                return void 0;\r\n            }\r\n            finally {\r\n                finalFn();\r\n            }\r\n        }, iter);\r\n    });\r\n}\r\nexport function enumerateUsing(disp, work) {\r\n    var isDisposed = false;\r\n    var disposeOnce = function () {\r\n        if (!isDisposed) {\r\n            isDisposed = true;\r\n            disp.Dispose();\r\n        }\r\n    };\r\n    try {\r\n        return enumerateThenFinally(work(disp), disposeOnce);\r\n    }\r\n    catch (err) {\r\n        return void 0;\r\n    }\r\n    finally {\r\n        disposeOnce();\r\n    }\r\n}\r\nexport function exactlyOne(xs) {\r\n    var iter = xs[Symbol.iterator]();\r\n    var fst = iter.next();\r\n    if (fst.done)\r\n        throw new Error(\"Seq was empty\");\r\n    var snd = iter.next();\r\n    if (!snd.done)\r\n        throw new Error(\"Seq had multiple items\");\r\n    return fst.value;\r\n}\r\nexport function except(itemsToExclude, source) {\r\n    var exclusionItems = Array.from(itemsToExclude);\r\n    var testIsNotInExclusionItems = function (element) { return !exclusionItems.some(function (excludedItem) { return equals(excludedItem, element); }); };\r\n    return filter(testIsNotInExclusionItems, source);\r\n}\r\nexport function exists(f, xs) {\r\n    function aux(iter) {\r\n        var cur = iter.next();\r\n        return !cur.done && (f(cur.value) || aux(iter));\r\n    }\r\n    return aux(xs[Symbol.iterator]());\r\n}\r\nexport function exists2(f, xs, ys) {\r\n    function aux(iter1, iter2) {\r\n        var cur1 = iter1.next(), cur2 = iter2.next();\r\n        return !cur1.done && !cur2.done && (f(cur1.value, cur2.value) || aux(iter1, iter2));\r\n    }\r\n    return aux(xs[Symbol.iterator](), ys[Symbol.iterator]());\r\n}\r\nexport function filter(f, xs) {\r\n    function trySkipToNext(iter) {\r\n        var cur = iter.next();\r\n        while (!cur.done) {\r\n            if (f(cur.value)) {\r\n                return [cur.value, iter];\r\n            }\r\n            cur = iter.next();\r\n        }\r\n        return void 0;\r\n    }\r\n    return delay(function () { return unfold(trySkipToNext, xs[Symbol.iterator]()); });\r\n}\r\nexport function where(f, xs) {\r\n    return filter(f, xs);\r\n}\r\nexport function fold(f, acc, xs) {\r\n    if (Array.isArray(xs) || ArrayBuffer.isView(xs)) {\r\n        return xs.reduce(f, acc);\r\n    }\r\n    else {\r\n        var cur = void 0;\r\n        for (var i = 0, iter = xs[Symbol.iterator]();; i++) {\r\n            cur = iter.next();\r\n            if (cur.done)\r\n                break;\r\n            acc = f(acc, cur.value, i);\r\n        }\r\n        return acc;\r\n    }\r\n}\r\nexport function foldBack(f, xs, acc) {\r\n    var arr = Array.isArray(xs) || ArrayBuffer.isView(xs) ? xs : Array.from(xs);\r\n    for (var i = arr.length - 1; i >= 0; i--) {\r\n        acc = f(arr[i], acc, i);\r\n    }\r\n    return acc;\r\n}\r\nexport function fold2(f, acc, xs, ys) {\r\n    var iter1 = xs[Symbol.iterator](), iter2 = ys[Symbol.iterator]();\r\n    var cur1, cur2;\r\n    for (var i = 0;; i++) {\r\n        cur1 = iter1.next();\r\n        cur2 = iter2.next();\r\n        if (cur1.done || cur2.done) {\r\n            break;\r\n        }\r\n        acc = f(acc, cur1.value, cur2.value, i);\r\n    }\r\n    return acc;\r\n}\r\nexport function foldBack2(f, xs, ys, acc) {\r\n    var ar1 = Array.isArray(xs) || ArrayBuffer.isView(xs) ? xs : Array.from(xs);\r\n    var ar2 = Array.isArray(ys) || ArrayBuffer.isView(ys) ? ys : Array.from(ys);\r\n    for (var i = ar1.length - 1; i >= 0; i--) {\r\n        acc = f(ar1[i], ar2[i], acc, i);\r\n    }\r\n    return acc;\r\n}\r\nexport function forAll(f, xs) {\r\n    return fold(function (acc, x) { return acc && f(x); }, true, xs);\r\n}\r\nexport function forAll2(f, xs, ys) {\r\n    return fold2(function (acc, x, y) { return acc && f(x, y); }, true, xs, ys);\r\n}\r\nexport function tryHead(xs) {\r\n    var iter = xs[Symbol.iterator]();\r\n    var cur = iter.next();\r\n    return cur.done ? null : cur.value;\r\n}\r\nexport function head(xs) {\r\n    return __failIfNone(tryHead(xs));\r\n}\r\nexport function initialize(n, f) {\r\n    return delay(function () {\r\n        return unfold(function (i) { return i < n ? [f(i), i + 1] : null; }, 0);\r\n    });\r\n}\r\nexport function initializeInfinite(f) {\r\n    return delay(function () {\r\n        return unfold(function (i) { return [f(i), i + 1]; }, 0);\r\n    });\r\n}\r\nexport function tryItem(i, xs) {\r\n    if (i < 0)\r\n        return null;\r\n    if (Array.isArray(xs) || ArrayBuffer.isView(xs))\r\n        return i < xs.length ? xs[i] : null;\r\n    for (var j = 0, iter = xs[Symbol.iterator]();; j++) {\r\n        var cur = iter.next();\r\n        if (cur.done)\r\n            return null;\r\n        if (j === i)\r\n            return cur.value;\r\n    }\r\n}\r\nexport function item(i, xs) {\r\n    return __failIfNone(tryItem(i, xs));\r\n}\r\nexport function iterate(f, xs) {\r\n    fold(function (_, x) { return f(x); }, null, xs);\r\n}\r\nexport function iterate2(f, xs, ys) {\r\n    fold2(function (_, x, y) { return f(x, y); }, null, xs, ys);\r\n}\r\nexport function iterateIndexed(f, xs) {\r\n    fold(function (_, x, i) { return f(i, x); }, null, xs);\r\n}\r\nexport function iterateIndexed2(f, xs, ys) {\r\n    fold2(function (_, x, y, i) { return f(i, x, y); }, null, xs, ys);\r\n}\r\nexport function isEmpty(xs) {\r\n    var i = xs[Symbol.iterator]();\r\n    return i.next().done;\r\n}\r\nexport function tryLast(xs) {\r\n    try {\r\n        return reduce(function (_, x) { return x; }, xs);\r\n    }\r\n    catch (err) {\r\n        return null;\r\n    }\r\n}\r\nexport function last(xs) {\r\n    return __failIfNone(tryLast(xs));\r\n}\r\nexport function count(xs) {\r\n    return Array.isArray(xs) || ArrayBuffer.isView(xs)\r\n        ? xs.length\r\n        : fold(function (acc, x) { return acc + 1; }, 0, xs);\r\n}\r\nexport function map(f, xs) {\r\n    return delay(function () { return unfold(function (iter) {\r\n        var cur = iter.next();\r\n        return !cur.done ? [f(cur.value), iter] : null;\r\n    }, xs[Symbol.iterator]()); });\r\n}\r\nexport function mapIndexed(f, xs) {\r\n    return delay(function () {\r\n        var i = 0;\r\n        return unfold(function (iter) {\r\n            var cur = iter.next();\r\n            return !cur.done ? [f(i++, cur.value), iter] : null;\r\n        }, xs[Symbol.iterator]());\r\n    });\r\n}\r\nexport function map2(f, xs, ys) {\r\n    return delay(function () {\r\n        var iter1 = xs[Symbol.iterator]();\r\n        var iter2 = ys[Symbol.iterator]();\r\n        return unfold(function () {\r\n            var cur1 = iter1.next(), cur2 = iter2.next();\r\n            return !cur1.done && !cur2.done ? [f(cur1.value, cur2.value), null] : null;\r\n        });\r\n    });\r\n}\r\nexport function mapIndexed2(f, xs, ys) {\r\n    return delay(function () {\r\n        var i = 0;\r\n        var iter1 = xs[Symbol.iterator]();\r\n        var iter2 = ys[Symbol.iterator]();\r\n        return unfold(function () {\r\n            var cur1 = iter1.next(), cur2 = iter2.next();\r\n            return !cur1.done && !cur2.done ? [f(i++, cur1.value, cur2.value), null] : null;\r\n        });\r\n    });\r\n}\r\nexport function map3(f, xs, ys, zs) {\r\n    return delay(function () {\r\n        var iter1 = xs[Symbol.iterator]();\r\n        var iter2 = ys[Symbol.iterator]();\r\n        var iter3 = zs[Symbol.iterator]();\r\n        return unfold(function () {\r\n            var cur1 = iter1.next(), cur2 = iter2.next(), cur3 = iter3.next();\r\n            return !cur1.done && !cur2.done && !cur3.done ? [f(cur1.value, cur2.value, cur3.value), null] : null;\r\n        });\r\n    });\r\n}\r\nexport function mapFold(f, acc, xs) {\r\n    var result = [];\r\n    var r;\r\n    var cur;\r\n    for (var i = 0, iter = xs[Symbol.iterator]();; i++) {\r\n        cur = iter.next();\r\n        if (cur.done)\r\n            break;\r\n        _a = f(acc, cur.value), r = _a[0], acc = _a[1];\r\n        result.push(r);\r\n    }\r\n    return [result, acc];\r\n    var _a;\r\n}\r\nexport function mapFoldBack(f, xs, acc) {\r\n    var arr = Array.isArray(xs) || ArrayBuffer.isView(xs) ? xs : Array.from(xs);\r\n    var result = [];\r\n    var r;\r\n    for (var i = arr.length - 1; i >= 0; i--) {\r\n        _a = f(arr[i], acc), r = _a[0], acc = _a[1];\r\n        result.push(r);\r\n    }\r\n    return [result, acc];\r\n    var _a;\r\n}\r\nexport function max(xs) {\r\n    return reduce(function (acc, x) { return compare(acc, x) === 1 ? acc : x; }, xs);\r\n}\r\nexport function maxBy(f, xs) {\r\n    return reduce(function (acc, x) { return compare(f(acc), f(x)) === 1 ? acc : x; }, xs);\r\n}\r\nexport function min(xs) {\r\n    return reduce(function (acc, x) { return compare(acc, x) === -1 ? acc : x; }, xs);\r\n}\r\nexport function minBy(f, xs) {\r\n    return reduce(function (acc, x) { return compare(f(acc), f(x)) === -1 ? acc : x; }, xs);\r\n}\r\nexport function pairwise(xs) {\r\n    return skip(2, scan(function (last, next) { return [last[1], next]; }, [0, 0], xs));\r\n}\r\nexport function permute(f, xs) {\r\n    return ofArray(arrayPermute(f, Array.from(xs)));\r\n}\r\nexport function rangeStep(first, step, last) {\r\n    if (step === 0)\r\n        throw new Error(\"Step cannot be 0\");\r\n    return delay(function () { return unfold(function (x) { return step > 0 && x <= last || step < 0 && x >= last ? [x, x + step] : null; }, first); });\r\n}\r\nexport function rangeChar(first, last) {\r\n    return delay(function () { return unfold(function (x) { return x <= last ? [x, String.fromCharCode(x.charCodeAt(0) + 1)] : null; }, first); });\r\n}\r\nexport function range(first, last) {\r\n    return rangeStep(first, 1, last);\r\n}\r\nexport function readOnly(xs) {\r\n    return map(function (x) { return x; }, xs);\r\n}\r\nexport function reduce(f, xs) {\r\n    if (Array.isArray(xs) || ArrayBuffer.isView(xs))\r\n        return xs.reduce(f);\r\n    var iter = xs[Symbol.iterator]();\r\n    var cur = iter.next();\r\n    if (cur.done)\r\n        throw new Error(\"Seq was empty\");\r\n    var acc = cur.value;\r\n    for (;;) {\r\n        cur = iter.next();\r\n        if (cur.done)\r\n            break;\r\n        acc = f(acc, cur.value);\r\n    }\r\n    return acc;\r\n}\r\nexport function reduceBack(f, xs) {\r\n    var ar = Array.isArray(xs) || ArrayBuffer.isView(xs) ? xs : Array.from(xs);\r\n    if (ar.length === 0)\r\n        throw new Error(\"Seq was empty\");\r\n    var acc = ar[ar.length - 1];\r\n    for (var i = ar.length - 2; i >= 0; i--)\r\n        acc = f(ar[i], acc, i);\r\n    return acc;\r\n}\r\nexport function replicate(n, x) {\r\n    return initialize(n, function () { return x; });\r\n}\r\nexport function reverse(xs) {\r\n    var ar = Array.isArray(xs) || ArrayBuffer.isView(xs) ? xs.slice(0) : Array.from(xs);\r\n    return ofArray(ar.reverse());\r\n}\r\nexport function scan(f, seed, xs) {\r\n    return delay(function () {\r\n        var iter = xs[Symbol.iterator]();\r\n        return unfold(function (acc) {\r\n            if (acc == null)\r\n                return [seed, seed];\r\n            var cur = iter.next();\r\n            if (!cur.done) {\r\n                acc = f(acc, cur.value);\r\n                return [acc, acc];\r\n            }\r\n            return void 0;\r\n        }, null);\r\n    });\r\n}\r\nexport function scanBack(f, xs, seed) {\r\n    return reverse(scan(function (acc, x) { return f(x, acc); }, seed, reverse(xs)));\r\n}\r\nexport function singleton(x) {\r\n    return unfold(function (x) { return x != null ? [x, null] : null; }, x);\r\n}\r\nexport function skip(n, xs) {\r\n    return _a = {},\r\n        _a[Symbol.iterator] = function () {\r\n            var iter = xs[Symbol.iterator]();\r\n            for (var i = 1; i <= n; i++)\r\n                if (iter.next().done)\r\n                    throw new Error(\"Seq has not enough elements\");\r\n            return iter;\r\n        },\r\n        _a;\r\n    var _a;\r\n}\r\nexport function skipWhile(f, xs) {\r\n    return delay(function () {\r\n        var hasPassed = false;\r\n        return filter(function (x) { return hasPassed || (hasPassed = !f(x)); }, xs);\r\n    });\r\n}\r\nexport function sortWith(f, xs) {\r\n    var ys = Array.from(xs);\r\n    return ofArray(ys.sort(f));\r\n}\r\nexport function sum(xs) {\r\n    return fold(function (acc, x) { return acc + x; }, 0, xs);\r\n}\r\nexport function sumBy(f, xs) {\r\n    return fold(function (acc, x) { return acc + f(x); }, 0, xs);\r\n}\r\nexport function tail(xs) {\r\n    var iter = xs[Symbol.iterator]();\r\n    var cur = iter.next();\r\n    if (cur.done)\r\n        throw new Error(\"Seq was empty\");\r\n    return _a = {},\r\n        _a[Symbol.iterator] = function () { return iter; },\r\n        _a;\r\n    var _a;\r\n}\r\nexport function take(n, xs, truncate) {\r\n    if (truncate === void 0) { truncate = false; }\r\n    return delay(function () {\r\n        var iter = xs[Symbol.iterator]();\r\n        return unfold(function (i) {\r\n            if (i < n) {\r\n                var cur = iter.next();\r\n                if (!cur.done)\r\n                    return [cur.value, i + 1];\r\n                if (!truncate)\r\n                    throw new Error(\"Seq has not enough elements\");\r\n            }\r\n            return void 0;\r\n        }, 0);\r\n    });\r\n}\r\nexport function truncate(n, xs) {\r\n    return take(n, xs, true);\r\n}\r\nexport function takeWhile(f, xs) {\r\n    return delay(function () {\r\n        var iter = xs[Symbol.iterator]();\r\n        return unfold(function (i) {\r\n            var cur = iter.next();\r\n            if (!cur.done && f(cur.value))\r\n                return [cur.value, null];\r\n            return void 0;\r\n        }, 0);\r\n    });\r\n}\r\nexport function tryFind(f, xs, defaultValue) {\r\n    for (var i = 0, iter = xs[Symbol.iterator]();; i++) {\r\n        var cur = iter.next();\r\n        if (cur.done)\r\n            return defaultValue === void 0 ? null : defaultValue;\r\n        if (f(cur.value, i))\r\n            return cur.value;\r\n    }\r\n}\r\nexport function find(f, xs) {\r\n    return __failIfNone(tryFind(f, xs));\r\n}\r\nexport function tryFindBack(f, xs, defaultValue) {\r\n    var match = null;\r\n    for (var i = 0, iter = xs[Symbol.iterator]();; i++) {\r\n        var cur = iter.next();\r\n        if (cur.done)\r\n            return match === null ? (defaultValue === void 0 ? null : defaultValue) : match;\r\n        if (f(cur.value, i))\r\n            match = cur.value;\r\n    }\r\n}\r\nexport function findBack(f, xs) {\r\n    return __failIfNone(tryFindBack(f, xs));\r\n}\r\nexport function tryFindIndex(f, xs) {\r\n    for (var i = 0, iter = xs[Symbol.iterator]();; i++) {\r\n        var cur = iter.next();\r\n        if (cur.done)\r\n            return null;\r\n        if (f(cur.value, i))\r\n            return i;\r\n    }\r\n}\r\nexport function findIndex(f, xs) {\r\n    return __failIfNone(tryFindIndex(f, xs));\r\n}\r\nexport function tryFindIndexBack(f, xs) {\r\n    var match = -1;\r\n    for (var i = 0, iter = xs[Symbol.iterator]();; i++) {\r\n        var cur = iter.next();\r\n        if (cur.done)\r\n            return match === -1 ? null : match;\r\n        if (f(cur.value, i))\r\n            match = i;\r\n    }\r\n}\r\nexport function findIndexBack(f, xs) {\r\n    return __failIfNone(tryFindIndexBack(f, xs));\r\n}\r\nexport function tryPick(f, xs) {\r\n    for (var i = 0, iter = xs[Symbol.iterator]();; i++) {\r\n        var cur = iter.next();\r\n        if (cur.done)\r\n            break;\r\n        var y = f(cur.value, i);\r\n        if (y != null)\r\n            return y;\r\n    }\r\n    return void 0;\r\n}\r\nexport function pick(f, xs) {\r\n    return __failIfNone(tryPick(f, xs));\r\n}\r\nexport function unfold(f, acc) {\r\n    return _a = {},\r\n        _a[Symbol.iterator] = function () {\r\n            return {\r\n                next: function () {\r\n                    var res = f(acc);\r\n                    if (res != null) {\r\n                        acc = res[1];\r\n                        return { done: false, value: res[0] };\r\n                    }\r\n                    return { done: true };\r\n                }\r\n            };\r\n        },\r\n        _a;\r\n    var _a;\r\n}\r\nexport function zip(xs, ys) {\r\n    return map2(function (x, y) { return [x, y]; }, xs, ys);\r\n}\r\nexport function zip3(xs, ys, zs) {\r\n    return map3(function (x, y, z) { return [x, y, z]; }, xs, ys, zs);\r\n}\r\n","import List from \"./ListClass\";\r\nimport { ofArray as listOfArray } from \"./ListClass\";\r\nimport { toString } from \"./Util\";\r\nimport { equals } from \"./Util\";\r\nimport { compare } from \"./Util\";\r\nimport GenericComparer from \"./GenericComparer\";\r\nimport FSymbol from \"./Symbol\";\r\nimport { map as seqMap } from \"./Seq\";\r\nimport { fold as seqFold } from \"./Seq\";\r\nimport { pick as seqPick } from \"./Seq\";\r\nimport { tryPick as seqTryPick } from \"./Seq\";\r\nimport { compareWith as seqCompareWith } from \"./Seq\";\r\nexport function groupBy(f, xs) {\r\n    var keys = [], iter = xs[Symbol.iterator]();\r\n    var acc = create(), cur = iter.next();\r\n    while (!cur.done) {\r\n        var k = f(cur.value), vs = tryFind(k, acc);\r\n        if (vs == null) {\r\n            keys.push(k);\r\n            acc = add(k, [cur.value], acc);\r\n        }\r\n        else {\r\n            vs.push(cur.value);\r\n        }\r\n        cur = iter.next();\r\n    }\r\n    return keys.map(function (k) { return [k, acc.get(k)]; });\r\n}\r\nexport function countBy(f, xs) {\r\n    return groupBy(f, xs).map(function (kv) { return [kv[0], kv[1].length]; });\r\n}\r\nvar MapTree = (function () {\r\n    function MapTree(caseName, fields) {\r\n        this.Case = caseName;\r\n        this.Fields = fields;\r\n    }\r\n    return MapTree;\r\n}());\r\nexport { MapTree };\r\nfunction tree_sizeAux(acc, m) {\r\n    return m.Case === \"MapOne\"\r\n        ? acc + 1\r\n        : m.Case === \"MapNode\"\r\n            ? tree_sizeAux(tree_sizeAux(acc + 1, m.Fields[2]), m.Fields[3])\r\n            : acc;\r\n}\r\nfunction tree_size(x) {\r\n    return tree_sizeAux(0, x);\r\n}\r\nfunction tree_empty() {\r\n    return new MapTree(\"MapEmpty\", []);\r\n}\r\nfunction tree_height(_arg1) {\r\n    return _arg1.Case === \"MapOne\" ? 1 : _arg1.Case === \"MapNode\" ? _arg1.Fields[4] : 0;\r\n}\r\nfunction tree_isEmpty(m) {\r\n    return m.Case === \"MapEmpty\" ? true : false;\r\n}\r\nfunction tree_mk(l, k, v, r) {\r\n    var matchValue = [l, r];\r\n    var $target1 = function () {\r\n        var hl = tree_height(l);\r\n        var hr = tree_height(r);\r\n        var m = hl < hr ? hr : hl;\r\n        return new MapTree(\"MapNode\", [k, v, l, r, m + 1]);\r\n    };\r\n    if (matchValue[0].Case === \"MapEmpty\") {\r\n        if (matchValue[1].Case === \"MapEmpty\") {\r\n            return new MapTree(\"MapOne\", [k, v]);\r\n        }\r\n        else {\r\n            return $target1();\r\n        }\r\n    }\r\n    else {\r\n        return $target1();\r\n    }\r\n}\r\n;\r\nfunction tree_rebalance(t1, k, v, t2) {\r\n    var t1h = tree_height(t1);\r\n    var t2h = tree_height(t2);\r\n    if (t2h > t1h + 2) {\r\n        if (t2.Case === \"MapNode\") {\r\n            if (tree_height(t2.Fields[2]) > t1h + 1) {\r\n                if (t2.Fields[2].Case === \"MapNode\") {\r\n                    return tree_mk(tree_mk(t1, k, v, t2.Fields[2].Fields[2]), t2.Fields[2].Fields[0], t2.Fields[2].Fields[1], tree_mk(t2.Fields[2].Fields[3], t2.Fields[0], t2.Fields[1], t2.Fields[3]));\r\n                }\r\n                else {\r\n                    throw new Error(\"rebalance\");\r\n                }\r\n            }\r\n            else {\r\n                return tree_mk(tree_mk(t1, k, v, t2.Fields[2]), t2.Fields[0], t2.Fields[1], t2.Fields[3]);\r\n            }\r\n        }\r\n        else {\r\n            throw new Error(\"rebalance\");\r\n        }\r\n    }\r\n    else {\r\n        if (t1h > t2h + 2) {\r\n            if (t1.Case === \"MapNode\") {\r\n                if (tree_height(t1.Fields[3]) > t2h + 1) {\r\n                    if (t1.Fields[3].Case === \"MapNode\") {\r\n                        return tree_mk(tree_mk(t1.Fields[2], t1.Fields[0], t1.Fields[1], t1.Fields[3].Fields[2]), t1.Fields[3].Fields[0], t1.Fields[3].Fields[1], tree_mk(t1.Fields[3].Fields[3], k, v, t2));\r\n                    }\r\n                    else {\r\n                        throw new Error(\"rebalance\");\r\n                    }\r\n                }\r\n                else {\r\n                    return tree_mk(t1.Fields[2], t1.Fields[0], t1.Fields[1], tree_mk(t1.Fields[3], k, v, t2));\r\n                }\r\n            }\r\n            else {\r\n                throw new Error(\"rebalance\");\r\n            }\r\n        }\r\n        else {\r\n            return tree_mk(t1, k, v, t2);\r\n        }\r\n    }\r\n}\r\nfunction tree_add(comparer, k, v, m) {\r\n    if (m.Case === \"MapOne\") {\r\n        var c = comparer.Compare(k, m.Fields[0]);\r\n        if (c < 0) {\r\n            return new MapTree(\"MapNode\", [k, v, new MapTree(\"MapEmpty\", []), m, 2]);\r\n        }\r\n        else if (c === 0) {\r\n            return new MapTree(\"MapOne\", [k, v]);\r\n        }\r\n        return new MapTree(\"MapNode\", [k, v, m, new MapTree(\"MapEmpty\", []), 2]);\r\n    }\r\n    else if (m.Case === \"MapNode\") {\r\n        var c = comparer.Compare(k, m.Fields[0]);\r\n        if (c < 0) {\r\n            return tree_rebalance(tree_add(comparer, k, v, m.Fields[2]), m.Fields[0], m.Fields[1], m.Fields[3]);\r\n        }\r\n        else if (c === 0) {\r\n            return new MapTree(\"MapNode\", [k, v, m.Fields[2], m.Fields[3], m.Fields[4]]);\r\n        }\r\n        return tree_rebalance(m.Fields[2], m.Fields[0], m.Fields[1], tree_add(comparer, k, v, m.Fields[3]));\r\n    }\r\n    return new MapTree(\"MapOne\", [k, v]);\r\n}\r\nfunction tree_find(comparer, k, m) {\r\n    var res = tree_tryFind(comparer, k, m);\r\n    if (res != null)\r\n        return res;\r\n    throw new Error(\"key not found\");\r\n}\r\nfunction tree_tryFind(comparer, k, m) {\r\n    if (m.Case === \"MapOne\") {\r\n        var c = comparer.Compare(k, m.Fields[0]);\r\n        return c === 0 ? m.Fields[1] : null;\r\n    }\r\n    else if (m.Case === \"MapNode\") {\r\n        var c = comparer.Compare(k, m.Fields[0]);\r\n        if (c < 0) {\r\n            return tree_tryFind(comparer, k, m.Fields[2]);\r\n        }\r\n        else {\r\n            if (c === 0) {\r\n                return m.Fields[1];\r\n            }\r\n            else {\r\n                return tree_tryFind(comparer, k, m.Fields[3]);\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}\r\nfunction tree_partition1(comparer, f, k, v, acc1, acc2) {\r\n    return f(k, v) ? [tree_add(comparer, k, v, acc1), acc2] : [acc1, tree_add(comparer, k, v, acc2)];\r\n}\r\nfunction tree_partitionAux(comparer, f, s, acc_0, acc_1) {\r\n    var acc = [acc_0, acc_1];\r\n    if (s.Case === \"MapOne\") {\r\n        return tree_partition1(comparer, f, s.Fields[0], s.Fields[1], acc[0], acc[1]);\r\n    }\r\n    else if (s.Case === \"MapNode\") {\r\n        var acc_2 = tree_partitionAux(comparer, f, s.Fields[3], acc[0], acc[1]);\r\n        var acc_3 = tree_partition1(comparer, f, s.Fields[0], s.Fields[1], acc_2[0], acc_2[1]);\r\n        return tree_partitionAux(comparer, f, s.Fields[2], acc_3[0], acc_3[1]);\r\n    }\r\n    return acc;\r\n}\r\nfunction tree_partition(comparer, f, s) {\r\n    return tree_partitionAux(comparer, f, s, tree_empty(), tree_empty());\r\n}\r\nfunction tree_filter1(comparer, f, k, v, acc) {\r\n    return f(k, v) ? tree_add(comparer, k, v, acc) : acc;\r\n}\r\nfunction tree_filterAux(comparer, f, s, acc) {\r\n    return s.Case === \"MapOne\" ? tree_filter1(comparer, f, s.Fields[0], s.Fields[1], acc) : s.Case === \"MapNode\" ? tree_filterAux(comparer, f, s.Fields[3], tree_filter1(comparer, f, s.Fields[0], s.Fields[1], tree_filterAux(comparer, f, s.Fields[2], acc))) : acc;\r\n}\r\nfunction tree_filter(comparer, f, s) {\r\n    return tree_filterAux(comparer, f, s, tree_empty());\r\n}\r\nfunction tree_spliceOutSuccessor(m) {\r\n    if (m.Case === \"MapOne\") {\r\n        return [m.Fields[0], m.Fields[1], new MapTree(\"MapEmpty\", [])];\r\n    }\r\n    else if (m.Case === \"MapNode\") {\r\n        if (m.Fields[2].Case === \"MapEmpty\") {\r\n            return [m.Fields[0], m.Fields[1], m.Fields[3]];\r\n        }\r\n        else {\r\n            var kvl = tree_spliceOutSuccessor(m.Fields[2]);\r\n            return [kvl[0], kvl[1], tree_mk(kvl[2], m.Fields[0], m.Fields[1], m.Fields[3])];\r\n        }\r\n    }\r\n    throw new Error(\"internal error: Map.spliceOutSuccessor\");\r\n}\r\nfunction tree_remove(comparer, k, m) {\r\n    if (m.Case === \"MapOne\") {\r\n        var c = comparer.Compare(k, m.Fields[0]);\r\n        if (c === 0) {\r\n            return new MapTree(\"MapEmpty\", []);\r\n        }\r\n        else {\r\n            return m;\r\n        }\r\n    }\r\n    else if (m.Case === \"MapNode\") {\r\n        var c = comparer.Compare(k, m.Fields[0]);\r\n        if (c < 0) {\r\n            return tree_rebalance(tree_remove(comparer, k, m.Fields[2]), m.Fields[0], m.Fields[1], m.Fields[3]);\r\n        }\r\n        else {\r\n            if (c === 0) {\r\n                var matchValue = [m.Fields[2], m.Fields[3]];\r\n                if (matchValue[0].Case === \"MapEmpty\") {\r\n                    return m.Fields[3];\r\n                }\r\n                else {\r\n                    if (matchValue[1].Case === \"MapEmpty\") {\r\n                        return m.Fields[2];\r\n                    }\r\n                    else {\r\n                        var patternInput = tree_spliceOutSuccessor(m.Fields[3]);\r\n                        var sv = patternInput[1];\r\n                        var sk = patternInput[0];\r\n                        var r_ = patternInput[2];\r\n                        return tree_mk(m.Fields[2], sk, sv, r_);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                return tree_rebalance(m.Fields[2], m.Fields[0], m.Fields[1], tree_remove(comparer, k, m.Fields[3]));\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        return tree_empty();\r\n    }\r\n}\r\nfunction tree_mem(comparer, k, m) {\r\n    if (m.Case === \"MapOne\") {\r\n        return comparer.Compare(k, m.Fields[0]) === 0;\r\n    }\r\n    else if (m.Case === \"MapNode\") {\r\n        var c = comparer.Compare(k, m.Fields[0]);\r\n        if (c < 0) {\r\n            return tree_mem(comparer, k, m.Fields[2]);\r\n        }\r\n        else {\r\n            if (c === 0) {\r\n                return true;\r\n            }\r\n            else {\r\n                return tree_mem(comparer, k, m.Fields[3]);\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        return false;\r\n    }\r\n}\r\nfunction tree_iter(f, m) {\r\n    if (m.Case === \"MapOne\") {\r\n        f(m.Fields[0], m.Fields[1]);\r\n    }\r\n    else if (m.Case === \"MapNode\") {\r\n        tree_iter(f, m.Fields[2]);\r\n        f(m.Fields[0], m.Fields[1]);\r\n        tree_iter(f, m.Fields[3]);\r\n    }\r\n}\r\nfunction tree_tryPick(f, m) {\r\n    if (m.Case === \"MapOne\") {\r\n        return f(m.Fields[0], m.Fields[1]);\r\n    }\r\n    else if (m.Case === \"MapNode\") {\r\n        var matchValue = tree_tryPick(f, m.Fields[2]);\r\n        if (matchValue == null) {\r\n            var matchValue_1 = f(m.Fields[0], m.Fields[1]);\r\n            if (matchValue_1 == null) {\r\n                return tree_tryPick(f, m.Fields[3]);\r\n            }\r\n            else {\r\n                var res = matchValue_1;\r\n                return res;\r\n            }\r\n        }\r\n        else {\r\n            var res = matchValue;\r\n            return res;\r\n        }\r\n    }\r\n    else {\r\n        return null;\r\n    }\r\n}\r\nfunction tree_exists(f, m) {\r\n    return m.Case === \"MapOne\" ? f(m.Fields[0], m.Fields[1]) : m.Case === \"MapNode\" ? (tree_exists(f, m.Fields[2]) ? true : f(m.Fields[0], m.Fields[1])) ? true : tree_exists(f, m.Fields[3]) : false;\r\n}\r\nfunction tree_forall(f, m) {\r\n    return m.Case === \"MapOne\" ? f(m.Fields[0], m.Fields[1]) : m.Case === \"MapNode\" ? (tree_forall(f, m.Fields[2]) ? f(m.Fields[0], m.Fields[1]) : false) ? tree_forall(f, m.Fields[3]) : false : true;\r\n}\r\nfunction tree_mapi(f, m) {\r\n    return m.Case === \"MapOne\" ? new MapTree(\"MapOne\", [m.Fields[0], f(m.Fields[0], m.Fields[1])]) : m.Case === \"MapNode\" ? new MapTree(\"MapNode\", [m.Fields[0], f(m.Fields[0], m.Fields[1]), tree_mapi(f, m.Fields[2]), tree_mapi(f, m.Fields[3]), m.Fields[4]]) : tree_empty();\r\n}\r\nfunction tree_foldBack(f, m, x) {\r\n    return m.Case === \"MapOne\" ? f(m.Fields[0], m.Fields[1], x) : m.Case === \"MapNode\" ? tree_foldBack(f, m.Fields[2], f(m.Fields[0], m.Fields[1], tree_foldBack(f, m.Fields[3], x))) : x;\r\n}\r\nfunction tree_fold(f, x, m) {\r\n    return m.Case === \"MapOne\" ? f(x, m.Fields[0], m.Fields[1]) : m.Case === \"MapNode\" ? tree_fold(f, f(tree_fold(f, x, m.Fields[2]), m.Fields[0], m.Fields[1]), m.Fields[3]) : x;\r\n}\r\nfunction tree_mkFromEnumerator(comparer, acc, e) {\r\n    var cur = e.next();\r\n    while (!cur.done) {\r\n        acc = tree_add(comparer, cur.value[0], cur.value[1], acc);\r\n        cur = e.next();\r\n    }\r\n    return acc;\r\n}\r\nfunction tree_ofSeq(comparer, c) {\r\n    var ie = c[Symbol.iterator]();\r\n    return tree_mkFromEnumerator(comparer, tree_empty(), ie);\r\n}\r\nfunction tree_collapseLHS(stack) {\r\n    if (stack.tail != null) {\r\n        if (stack.head.Case === \"MapOne\") {\r\n            return stack;\r\n        }\r\n        else if (stack.head.Case === \"MapNode\") {\r\n            return tree_collapseLHS(listOfArray([\r\n                stack.head.Fields[2],\r\n                new MapTree(\"MapOne\", [stack.head.Fields[0], stack.head.Fields[1]]),\r\n                stack.head.Fields[3]\r\n            ], stack.tail));\r\n        }\r\n        else {\r\n            return tree_collapseLHS(stack.tail);\r\n        }\r\n    }\r\n    else {\r\n        return new List();\r\n    }\r\n}\r\nfunction tree_mkIterator(s) {\r\n    return { stack: tree_collapseLHS(new List(s, new List())), started: false };\r\n}\r\nfunction tree_moveNext(i) {\r\n    function current(i) {\r\n        if (i.stack.tail == null) {\r\n            return null;\r\n        }\r\n        else if (i.stack.head.Case === \"MapOne\") {\r\n            return [i.stack.head.Fields[0], i.stack.head.Fields[1]];\r\n        }\r\n        throw new Error(\"Please report error: Map iterator, unexpected stack for current\");\r\n    }\r\n    if (i.started) {\r\n        if (i.stack.tail == null) {\r\n            return { done: true, value: null };\r\n        }\r\n        else {\r\n            if (i.stack.head.Case === \"MapOne\") {\r\n                i.stack = tree_collapseLHS(i.stack.tail);\r\n                return {\r\n                    done: i.stack.tail == null,\r\n                    value: current(i)\r\n                };\r\n            }\r\n            else {\r\n                throw new Error(\"Please report error: Map iterator, unexpected stack for moveNext\");\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        i.started = true;\r\n        return {\r\n            done: i.stack.tail == null,\r\n            value: current(i)\r\n        };\r\n    }\r\n    ;\r\n}\r\nvar FableMap = (function () {\r\n    function FableMap() {\r\n    }\r\n    FableMap.prototype.ToString = function () {\r\n        return \"map [\" + Array.from(this).map(toString).join(\"; \") + \"]\";\r\n    };\r\n    FableMap.prototype.Equals = function (m2) {\r\n        return this.CompareTo(m2) === 0;\r\n    };\r\n    FableMap.prototype.CompareTo = function (m2) {\r\n        var _this = this;\r\n        return this === m2 ? 0 : seqCompareWith(function (kvp1, kvp2) {\r\n            var c = _this.comparer.Compare(kvp1[0], kvp2[0]);\r\n            return c !== 0 ? c : compare(kvp1[1], kvp2[1]);\r\n        }, this, m2);\r\n    };\r\n    FableMap.prototype[Symbol.iterator] = function () {\r\n        var i = tree_mkIterator(this.tree);\r\n        return {\r\n            next: function () { return tree_moveNext(i); }\r\n        };\r\n    };\r\n    FableMap.prototype.entries = function () {\r\n        return this[Symbol.iterator]();\r\n    };\r\n    FableMap.prototype.keys = function () {\r\n        return seqMap(function (kv) { return kv[0]; }, this);\r\n    };\r\n    FableMap.prototype.values = function () {\r\n        return seqMap(function (kv) { return kv[1]; }, this);\r\n    };\r\n    FableMap.prototype.get = function (k) {\r\n        return tree_find(this.comparer, k, this.tree);\r\n    };\r\n    FableMap.prototype.has = function (k) {\r\n        return tree_mem(this.comparer, k, this.tree);\r\n    };\r\n    FableMap.prototype.set = function (k, v) {\r\n        throw new Error(\"not supported\");\r\n    };\r\n    FableMap.prototype.delete = function (k) {\r\n        throw new Error(\"not supported\");\r\n    };\r\n    FableMap.prototype.clear = function () {\r\n        throw new Error(\"not supported\");\r\n    };\r\n    Object.defineProperty(FableMap.prototype, \"size\", {\r\n        get: function () {\r\n            return tree_size(this.tree);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    FableMap.prototype[FSymbol.reflection] = function () {\r\n        return {\r\n            type: \"Microsoft.FSharp.Collections.FSharpMap\",\r\n            interfaces: [\"System.IEquatable\", \"System.IComparable\", \"System.Collections.Generic.IDictionary\"]\r\n        };\r\n    };\r\n    return FableMap;\r\n}());\r\nexport default FableMap;\r\nfunction from(comparer, tree) {\r\n    var map = new FableMap();\r\n    map.tree = tree;\r\n    map.comparer = comparer || new GenericComparer();\r\n    return map;\r\n}\r\nexport function create(ie, comparer) {\r\n    comparer = comparer || new GenericComparer();\r\n    return from(comparer, ie ? tree_ofSeq(comparer, ie) : tree_empty());\r\n}\r\nexport function add(k, v, map) {\r\n    return from(map.comparer, tree_add(map.comparer, k, v, map.tree));\r\n}\r\nexport function remove(item, map) {\r\n    return from(map.comparer, tree_remove(map.comparer, item, map.tree));\r\n}\r\nexport function containsValue(v, map) {\r\n    return seqFold(function (acc, k) { return acc || equals(map.get(k), v); }, false, map.keys());\r\n}\r\nexport function tryGetValue(map, key, defaultValue) {\r\n    return map.has(key) ? [true, map.get(key)] : [false, defaultValue];\r\n}\r\nexport function exists(f, map) {\r\n    return tree_exists(f, map.tree);\r\n}\r\nexport function find(k, map) {\r\n    return tree_find(map.comparer, k, map.tree);\r\n}\r\nexport function tryFind(k, map) {\r\n    return tree_tryFind(map.comparer, k, map.tree);\r\n}\r\nexport function filter(f, map) {\r\n    return from(map.comparer, tree_filter(map.comparer, f, map.tree));\r\n}\r\nexport function fold(f, seed, map) {\r\n    return tree_fold(f, seed, map.tree);\r\n}\r\nexport function foldBack(f, map, seed) {\r\n    return tree_foldBack(f, map.tree, seed);\r\n}\r\nexport function forAll(f, map) {\r\n    return tree_forall(f, map.tree);\r\n}\r\nexport function isEmpty(map) {\r\n    return tree_isEmpty(map.tree);\r\n}\r\nexport function iterate(f, map) {\r\n    tree_iter(f, map.tree);\r\n}\r\nexport function map(f, map) {\r\n    return from(map.comparer, tree_mapi(f, map.tree));\r\n}\r\nexport function partition(f, map) {\r\n    var rs = tree_partition(map.comparer, f, map.tree);\r\n    return [from(map.comparer, rs[0]), from(map.comparer, rs[1])];\r\n}\r\nexport function findKey(f, map) {\r\n    return seqPick(function (kv) { return f(kv[0], kv[1]) ? kv[0] : null; }, map);\r\n}\r\nexport function tryFindKey(f, map) {\r\n    return seqTryPick(function (kv) { return f(kv[0], kv[1]) ? kv[0] : null; }, map);\r\n}\r\nexport function pick(f, map) {\r\n    var res = tryPick(f, map);\r\n    if (res != null)\r\n        return res;\r\n    throw new Error(\"key not found\");\r\n}\r\nexport function tryPick(f, map) {\r\n    return tree_tryPick(f, map.tree);\r\n}\r\n","import List from \"./ListClass\";\r\nimport { map as seqMap } from \"./Seq\";\r\nimport { fold as seqFold } from \"./Seq\";\r\nimport { foldBack as seqFoldBack } from \"./Seq\";\r\nimport { toList as seqToList } from \"./Seq\";\r\nimport { groupBy as mapGroupBy } from \"./Map\";\r\nexport default List;\r\nexport { ofArray } from \"./ListClass\";\r\nexport function append(xs, ys) {\r\n    return seqFold(function (acc, x) { return new List(x, acc); }, ys, reverse(xs));\r\n}\r\nexport function choose(f, xs) {\r\n    var r = seqFold(function (acc, x) {\r\n        var y = f(x);\r\n        return y != null ? new List(y, acc) : acc;\r\n    }, new List(), xs);\r\n    return reverse(r);\r\n}\r\nexport function collect(f, xs) {\r\n    return seqFold(function (acc, x) { return append(acc, f(x)); }, new List(), xs);\r\n}\r\nexport function concat(xs) {\r\n    return collect(function (x) { return x; }, xs);\r\n}\r\nexport function filter(f, xs) {\r\n    return reverse(seqFold(function (acc, x) { return f(x) ? new List(x, acc) : acc; }, new List(), xs));\r\n}\r\nexport function where(f, xs) {\r\n    return filter(f, xs);\r\n}\r\nexport function initialize(n, f) {\r\n    if (n < 0) {\r\n        throw new Error(\"List length must be non-negative\");\r\n    }\r\n    var xs = new List();\r\n    for (var i = 1; i <= n; i++) {\r\n        xs = new List(f(n - i), xs);\r\n    }\r\n    return xs;\r\n}\r\nexport function map(f, xs) {\r\n    return reverse(seqFold(function (acc, x) { return new List(f(x), acc); }, new List(), xs));\r\n}\r\nexport function mapIndexed(f, xs) {\r\n    return reverse(seqFold(function (acc, x, i) { return new List(f(i, x), acc); }, new List(), xs));\r\n}\r\nexport function partition(f, xs) {\r\n    return seqFold(function (acc, x) {\r\n        var lacc = acc[0], racc = acc[1];\r\n        return f(x) ? [new List(x, lacc), racc] : [lacc, new List(x, racc)];\r\n    }, [new List(), new List()], reverse(xs));\r\n}\r\nexport function replicate(n, x) {\r\n    return initialize(n, function () { return x; });\r\n}\r\nexport function reverse(xs) {\r\n    return seqFold(function (acc, x) { return new List(x, acc); }, new List(), xs);\r\n}\r\nexport function singleton(x) {\r\n    return new List(x, new List());\r\n}\r\nexport function slice(lower, upper, xs) {\r\n    var noLower = (lower == null);\r\n    var noUpper = (upper == null);\r\n    return reverse(seqFold(function (acc, x, i) { return (noLower || lower <= i) && (noUpper || i <= upper) ? new List(x, acc) : acc; }, new List(), xs));\r\n}\r\nexport function unzip(xs) {\r\n    return seqFoldBack(function (xy, acc) {\r\n        return [new List(xy[0], acc[0]), new List(xy[1], acc[1])];\r\n    }, xs, [new List(), new List()]);\r\n}\r\nexport function unzip3(xs) {\r\n    return seqFoldBack(function (xyz, acc) {\r\n        return [new List(xyz[0], acc[0]), new List(xyz[1], acc[1]), new List(xyz[2], acc[2])];\r\n    }, xs, [new List(), new List(), new List()]);\r\n}\r\nexport function groupBy(f, xs) {\r\n    return seqToList(seqMap(function (k) { return [k[0], seqToList(k[1])]; }, mapGroupBy(f, xs)));\r\n}\r\n","﻿// Module that defines the instruction types and state\n\nnamespace Common\nmodule State =\n    \n    (*** STATE ***)\n\n    /// Represents the Machine State.\n    type StateHandle = S of Regs:int [] * N:bool * Z:bool * C:bool * S:bool * Mem:Map<int,int>\n\n    // Functions to access and modify state.\n\n    /// Creates default state.\n    let initState =\n        let regs = Array.create 16 0\n        S(regs, false, false, false, false, Map.empty)\n\n    /// Creates state for testing with visual - R13 initialized to 0xFF00000.\n    let initStateVisual =\n        let regs0to12 = Array.create 13 0\n        let regs13to15 = [|0xFF000000;0;0|]\n        let regs = Array.concat [regs0to12; regs13to15]\n\n        S(regs, false, false, false, false, Map.empty)\n\n    /// Read a register in the state.\n    let readReg r (S(reg,_,_,_,_,_): StateHandle) =\n        reg.[r]\n\n    /// Write a value to a register in the state.\n    let writeReg r v (S(reg,n,z,c,s,mem): StateHandle) =\n        let newRegs = Array.mapi (fun i x -> if r = i then v else x) reg\n        S(newRegs,n,z,c,s,mem)\n\n    /// Write a value to a register in the state and update status flags.\n    (*let writeRegFlags r v r1 r2 (S(reg,n,z,c,s,mem): StateHandle) =\n        let newRegs = Array.mapi (fun i x -> if r = i then v else x) reg\n        match v with\n        | x when (x < r1) && (x < r2) ->  *)\n\n    /// Read the value in the Program Counter.\n    let readPC (S(reg,_,_,_,_,_): StateHandle) =\n        reg.[15]\n\n    /// Write a value to the Program Counter.\n    let writePC v (S(reg,n,z,c,s,mem): StateHandle) =\n        let newRegs = Array.mapi (fun i x -> if i = 15 then v else x) reg\n        S(newRegs,n,z,c,s,mem)\n\n    /// Increment the Program Counter by 4.\n    let incPC (S(reg,n,z,c,s,mem): StateHandle) =\n        let newRegs = Array.mapi (fun i x -> if i = 15 then x+4 else x) reg\n        S(newRegs,n,z,c,s,mem)\n\n    /// Retrieve negative flag.\n    let readNFlag (S(_,n,_,_,_,_): StateHandle) = n\n\n    /// Retrieve zero flag.\n    let readZFlag (S(_,_,z,_,_,_): StateHandle) = z\n\n    /// Retrieve carry flag.\n    let readCFlag (S(_,_,_,c,_,_): StateHandle) = c\n    \n    /// Retrieve overflow flag.\n    let readVFlag (S(_,_,_,_,v,_): StateHandle) = v\n    \n    /// Write negative flag.\n    let writeNFlag n (S(reg,_,z,c,v,mem): StateHandle) =\n        S(reg,n,z,c,v,mem)\n\n    /// Write zero flag.\n    let writeZFlag z (S(reg,n,_,c,v,mem): StateHandle) =\n        S(reg,n,z,c,v,mem)\n\n    /// Write carry flag.\n    let writeCFlag c (S(reg,n,z,_,v,mem): StateHandle) =\n        S(reg,n,z,c,v,mem)\n    \n    /// Write overflow flag.\n    let writeVFlag v (S(reg,n,z,c,_,mem): StateHandle) =\n        S(reg,n,z,c,v,mem)\n\n    /// Read from a memory address.\n    let readMem addr (S(_,_,_,_,_,mem): StateHandle) =\n        match Map.tryFind addr mem with\n        | Some(v) -> v\n        | None -> 0\n\n    /// Write to a memory address.\n    let writeMem addr v (S(reg,n,z,c,s,mem): StateHandle) =\n        let newMem = Map.add addr v mem\n        S(reg,n,z,c,s,newMem)\n\n    /// Read a byte from a memory address.\n    let readMemByte addr (S(_,_,_,_,_,mem): StateHandle) =\n        match Map.tryFind (addr&&&0xFFFFFFFC) mem with\n        | Some(v) -> byte ((v>>>(8*(addr%4)))&&&255)\n        | None -> byte 0\n\n    /// Write a byte to a memory address.\n    let writeMemByte addr (b: byte) (S(reg,n,z,c,s,mem): StateHandle) =\n        let mask = 0xFFFFFFFF ^^^ (0xFF <<< (addr%4))\n        let newMem = match Map.tryFind (addr&&&0xFFFFFFFC) mem with\n                     | Some(v) -> Map.add addr ((mask&&&v) ||| (int (b<<<(8*(addr%4))))) mem\n                     | None -> Map.add addr (int (b<<<(8*(addr%4)))) mem\n        S(reg,n,z,c,s,newMem)\n\n    /// Debug. Returns tuple of (Registers * Flags)\n    let readState (S(reg,n,z,c,v,_): StateHandle) =\n        (reg, [n;z;c;v])\n\n    /// Debug. Returns tuple of (Registers * Flags* MemMap)\n    let readStateWithMem (S(reg,n,z,c,v,mem): StateHandle) =\n        (reg, [n;z;c;v], mem)","export function create(pattern, options) {\r\n    var flags = \"g\";\r\n    flags += options & 1 ? \"i\" : \"\";\r\n    flags += options & 2 ? \"m\" : \"\";\r\n    return new RegExp(pattern, flags);\r\n}\r\nexport function escape(str) {\r\n    return str.replace(/[\\-\\[\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, \"\\\\$&\");\r\n}\r\nexport function unescape(str) {\r\n    return str.replace(/\\\\([\\-\\[\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|])/g, \"$1\");\r\n}\r\nexport function isMatch(str, pattern, options) {\r\n    if (options === void 0) { options = 0; }\r\n    var reg = str instanceof RegExp\r\n        ? (reg = str, str = pattern, reg.lastIndex = options, reg)\r\n        : reg = create(pattern, options);\r\n    return reg.test(str);\r\n}\r\nexport function match(str, pattern, options) {\r\n    if (options === void 0) { options = 0; }\r\n    var reg = str instanceof RegExp\r\n        ? (reg = str, str = pattern, reg.lastIndex = options, reg)\r\n        : reg = create(pattern, options);\r\n    return reg.exec(str);\r\n}\r\nexport function matches(str, pattern, options) {\r\n    if (options === void 0) { options = 0; }\r\n    var reg = str instanceof RegExp\r\n        ? (reg = str, str = pattern, reg.lastIndex = options, reg)\r\n        : reg = create(pattern, options);\r\n    if (!reg.global)\r\n        throw new Error(\"Non-global RegExp\");\r\n    var m;\r\n    var matches = [];\r\n    while ((m = reg.exec(str)) !== null)\r\n        matches.push(m);\r\n    return matches;\r\n}\r\nexport function options(reg) {\r\n    var options = 256;\r\n    options |= reg.ignoreCase ? 1 : 0;\r\n    options |= reg.multiline ? 2 : 0;\r\n    return options;\r\n}\r\nexport function replace(reg, input, replacement, limit, offset) {\r\n    if (offset === void 0) { offset = 0; }\r\n    function replacer() {\r\n        var res = arguments[0];\r\n        if (limit !== 0) {\r\n            limit--;\r\n            var match_1 = [];\r\n            var len = arguments.length;\r\n            for (var i = 0; i < len - 2; i++)\r\n                match_1.push(arguments[i]);\r\n            match_1.index = arguments[len - 2];\r\n            match_1.input = arguments[len - 1];\r\n            res = replacement(match_1);\r\n        }\r\n        return res;\r\n    }\r\n    if (typeof reg == \"string\") {\r\n        var tmp = reg;\r\n        reg = create(input, limit);\r\n        input = tmp;\r\n        limit = undefined;\r\n    }\r\n    if (typeof replacement == \"function\") {\r\n        limit = limit == null ? -1 : limit;\r\n        return input.substring(0, offset) + input.substring(offset).replace(reg, replacer);\r\n    }\r\n    else {\r\n        if (limit != null) {\r\n            var m = void 0;\r\n            var sub1 = input.substring(offset);\r\n            var _matches = matches(reg, sub1);\r\n            var sub2 = matches.length > limit ? (m = _matches[limit - 1], sub1.substring(0, m.index + m[0].length)) : sub1;\r\n            return input.substring(0, offset) + sub2.replace(reg, replacement) + input.substring(offset + sub2.length);\r\n        }\r\n        else {\r\n            return input.replace(reg, replacement);\r\n        }\r\n    }\r\n}\r\nexport function split(reg, input, limit, offset) {\r\n    if (offset === void 0) { offset = 0; }\r\n    if (typeof reg == \"string\") {\r\n        var tmp = reg;\r\n        reg = create(input, limit);\r\n        input = tmp;\r\n        limit = undefined;\r\n    }\r\n    input = input.substring(offset);\r\n    return input.split(reg, limit);\r\n}\r\n","import _Symbol from \"./Symbol\";\r\nvar Long = (function () {\r\n    function Long(low, high, unsigned) {\r\n        this.eq = this.equals;\r\n        this.neq = this.notEquals;\r\n        this.lt = this.lessThan;\r\n        this.lte = this.lessThanOrEqual;\r\n        this.gt = this.greaterThan;\r\n        this.gte = this.greaterThanOrEqual;\r\n        this.comp = this.compare;\r\n        this.neg = this.negate;\r\n        this.abs = this.absolute;\r\n        this.sub = this.subtract;\r\n        this.mul = this.multiply;\r\n        this.div = this.divide;\r\n        this.mod = this.modulo;\r\n        this.shl = this.shiftLeft;\r\n        this.shr = this.shiftRight;\r\n        this.shru = this.shiftRightUnsigned;\r\n        this.Equals = this.equals;\r\n        this.CompareTo = this.compare;\r\n        this.ToString = this.toString;\r\n        this.low = low | 0;\r\n        this.high = high | 0;\r\n        this.unsigned = !!unsigned;\r\n    }\r\n    Long.prototype.toInt = function () {\r\n        return this.unsigned ? this.low >>> 0 : this.low;\r\n    };\r\n    Long.prototype.toNumber = function () {\r\n        if (this.unsigned)\r\n            return ((this.high >>> 0) * TWO_PWR_32_DBL) + (this.low >>> 0);\r\n        return this.high * TWO_PWR_32_DBL + (this.low >>> 0);\r\n    };\r\n    Long.prototype.toString = function (radix) {\r\n        if (radix === void 0) { radix = 10; }\r\n        radix = radix || 10;\r\n        if (radix < 2 || 36 < radix)\r\n            throw RangeError('radix');\r\n        if (this.isZero())\r\n            return '0';\r\n        if (this.isNegative()) {\r\n            if (this.eq(MIN_VALUE)) {\r\n                var radixLong = fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);\r\n                return div.toString(radix) + rem1.toInt().toString(radix);\r\n            }\r\n            else\r\n                return '-' + this.neg().toString(radix);\r\n        }\r\n        var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned), rem = this;\r\n        var result = '';\r\n        while (true) {\r\n            var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);\r\n            rem = remDiv;\r\n            if (rem.isZero())\r\n                return digits + result;\r\n            else {\r\n                while (digits.length < 6)\r\n                    digits = '0' + digits;\r\n                result = '' + digits + result;\r\n            }\r\n        }\r\n    };\r\n    Long.prototype.getHighBits = function () {\r\n        return this.high;\r\n    };\r\n    Long.prototype.getHighBitsUnsigned = function () {\r\n        return this.high >>> 0;\r\n    };\r\n    Long.prototype.getLowBits = function () {\r\n        return this.low;\r\n    };\r\n    Long.prototype.getLowBitsUnsigned = function () {\r\n        return this.low >>> 0;\r\n    };\r\n    Long.prototype.getNumBitsAbs = function () {\r\n        if (this.isNegative())\r\n            return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();\r\n        var val = this.high != 0 ? this.high : this.low;\r\n        for (var bit = 31; bit > 0; bit--)\r\n            if ((val & (1 << bit)) != 0)\r\n                break;\r\n        return this.high != 0 ? bit + 33 : bit + 1;\r\n    };\r\n    Long.prototype.isZero = function () {\r\n        return this.high === 0 && this.low === 0;\r\n    };\r\n    Long.prototype.isNegative = function () {\r\n        return !this.unsigned && this.high < 0;\r\n    };\r\n    Long.prototype.isPositive = function () {\r\n        return this.unsigned || this.high >= 0;\r\n    };\r\n    Long.prototype.isOdd = function () {\r\n        return (this.low & 1) === 1;\r\n    };\r\n    Long.prototype.isEven = function () {\r\n        return (this.low & 1) === 0;\r\n    };\r\n    Long.prototype.equals = function (other) {\r\n        if (!isLong(other))\r\n            other = fromValue(other);\r\n        if (this.unsigned !== other.unsigned && (this.high >>> 31) === 1 && (other.high >>> 31) === 1)\r\n            return false;\r\n        return this.high === other.high && this.low === other.low;\r\n    };\r\n    Long.prototype.notEquals = function (other) {\r\n        return !this.eq(other);\r\n    };\r\n    Long.prototype.lessThan = function (other) {\r\n        return this.comp(other) < 0;\r\n    };\r\n    Long.prototype.lessThanOrEqual = function (other) {\r\n        return this.comp(other) <= 0;\r\n    };\r\n    Long.prototype.greaterThan = function (other) {\r\n        return this.comp(other) > 0;\r\n    };\r\n    Long.prototype.greaterThanOrEqual = function (other) {\r\n        return this.comp(other) >= 0;\r\n    };\r\n    Long.prototype.compare = function (other) {\r\n        if (!isLong(other))\r\n            other = fromValue(other);\r\n        if (this.eq(other))\r\n            return 0;\r\n        var thisNeg = this.isNegative(), otherNeg = other.isNegative();\r\n        if (thisNeg && !otherNeg)\r\n            return -1;\r\n        if (!thisNeg && otherNeg)\r\n            return 1;\r\n        if (!this.unsigned)\r\n            return this.sub(other).isNegative() ? -1 : 1;\r\n        return (other.high >>> 0) > (this.high >>> 0) || (other.high === this.high && (other.low >>> 0) > (this.low >>> 0)) ? -1 : 1;\r\n    };\r\n    Long.prototype.negate = function () {\r\n        if (!this.unsigned && this.eq(MIN_VALUE))\r\n            return MIN_VALUE;\r\n        return this.not().add(ONE);\r\n    };\r\n    Long.prototype.absolute = function () {\r\n        if (!this.unsigned && this.isNegative())\r\n            return this.negate();\r\n        else\r\n            return this;\r\n    };\r\n    Long.prototype.add = function (addend) {\r\n        if (!isLong(addend))\r\n            addend = fromValue(addend);\r\n        var a48 = this.high >>> 16;\r\n        var a32 = this.high & 0xFFFF;\r\n        var a16 = this.low >>> 16;\r\n        var a00 = this.low & 0xFFFF;\r\n        var b48 = addend.high >>> 16;\r\n        var b32 = addend.high & 0xFFFF;\r\n        var b16 = addend.low >>> 16;\r\n        var b00 = addend.low & 0xFFFF;\r\n        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\r\n        c00 += a00 + b00;\r\n        c16 += c00 >>> 16;\r\n        c00 &= 0xFFFF;\r\n        c16 += a16 + b16;\r\n        c32 += c16 >>> 16;\r\n        c16 &= 0xFFFF;\r\n        c32 += a32 + b32;\r\n        c48 += c32 >>> 16;\r\n        c32 &= 0xFFFF;\r\n        c48 += a48 + b48;\r\n        c48 &= 0xFFFF;\r\n        return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);\r\n    };\r\n    Long.prototype.subtract = function (subtrahend) {\r\n        if (!isLong(subtrahend))\r\n            subtrahend = fromValue(subtrahend);\r\n        return this.add(subtrahend.neg());\r\n    };\r\n    Long.prototype.multiply = function (multiplier) {\r\n        if (this.isZero())\r\n            return ZERO;\r\n        if (!isLong(multiplier))\r\n            multiplier = fromValue(multiplier);\r\n        if (multiplier.isZero())\r\n            return ZERO;\r\n        if (this.eq(MIN_VALUE))\r\n            return multiplier.isOdd() ? MIN_VALUE : ZERO;\r\n        if (multiplier.eq(MIN_VALUE))\r\n            return this.isOdd() ? MIN_VALUE : ZERO;\r\n        if (this.isNegative()) {\r\n            if (multiplier.isNegative())\r\n                return this.neg().mul(multiplier.neg());\r\n            else\r\n                return this.neg().mul(multiplier).neg();\r\n        }\r\n        else if (multiplier.isNegative())\r\n            return this.mul(multiplier.neg()).neg();\r\n        if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))\r\n            return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);\r\n        var a48 = this.high >>> 16;\r\n        var a32 = this.high & 0xFFFF;\r\n        var a16 = this.low >>> 16;\r\n        var a00 = this.low & 0xFFFF;\r\n        var b48 = multiplier.high >>> 16;\r\n        var b32 = multiplier.high & 0xFFFF;\r\n        var b16 = multiplier.low >>> 16;\r\n        var b00 = multiplier.low & 0xFFFF;\r\n        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\r\n        c00 += a00 * b00;\r\n        c16 += c00 >>> 16;\r\n        c00 &= 0xFFFF;\r\n        c16 += a16 * b00;\r\n        c32 += c16 >>> 16;\r\n        c16 &= 0xFFFF;\r\n        c16 += a00 * b16;\r\n        c32 += c16 >>> 16;\r\n        c16 &= 0xFFFF;\r\n        c32 += a32 * b00;\r\n        c48 += c32 >>> 16;\r\n        c32 &= 0xFFFF;\r\n        c32 += a16 * b16;\r\n        c48 += c32 >>> 16;\r\n        c32 &= 0xFFFF;\r\n        c32 += a00 * b32;\r\n        c48 += c32 >>> 16;\r\n        c32 &= 0xFFFF;\r\n        c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;\r\n        c48 &= 0xFFFF;\r\n        return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);\r\n    };\r\n    Long.prototype.divide = function (divisor) {\r\n        if (!isLong(divisor))\r\n            divisor = fromValue(divisor);\r\n        if (divisor.isZero())\r\n            throw Error('division by zero');\r\n        if (this.isZero())\r\n            return this.unsigned ? UZERO : ZERO;\r\n        var approx = 0, rem = ZERO, res = ZERO;\r\n        if (!this.unsigned) {\r\n            if (this.eq(MIN_VALUE)) {\r\n                if (divisor.eq(ONE) || divisor.eq(NEG_ONE))\r\n                    return MIN_VALUE;\r\n                else if (divisor.eq(MIN_VALUE))\r\n                    return ONE;\r\n                else {\r\n                    var halfThis = this.shr(1);\r\n                    var approx_1 = halfThis.div(divisor).shl(1);\r\n                    if (approx_1.eq(ZERO)) {\r\n                        return divisor.isNegative() ? ONE : NEG_ONE;\r\n                    }\r\n                    else {\r\n                        rem = this.sub(divisor.mul(approx_1));\r\n                        res = approx_1.add(rem.div(divisor));\r\n                        return res;\r\n                    }\r\n                }\r\n            }\r\n            else if (divisor.eq(MIN_VALUE))\r\n                return this.unsigned ? UZERO : ZERO;\r\n            if (this.isNegative()) {\r\n                if (divisor.isNegative())\r\n                    return this.neg().div(divisor.neg());\r\n                return this.neg().div(divisor).neg();\r\n            }\r\n            else if (divisor.isNegative())\r\n                return this.div(divisor.neg()).neg();\r\n            res = ZERO;\r\n        }\r\n        else {\r\n            if (!divisor.unsigned)\r\n                divisor = divisor.toUnsigned();\r\n            if (divisor.gt(this))\r\n                return UZERO;\r\n            if (divisor.gt(this.shru(1)))\r\n                return UONE;\r\n            res = UZERO;\r\n        }\r\n        rem = this;\r\n        while (rem.gte(divisor)) {\r\n            approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));\r\n            var log2 = Math.ceil(Math.log(approx) / Math.LN2), delta = (log2 <= 48) ? 1 : pow_dbl(2, log2 - 48), approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);\r\n            while (approxRem.isNegative() || approxRem.gt(rem)) {\r\n                approx -= delta;\r\n                approxRes = fromNumber(approx, this.unsigned);\r\n                approxRem = approxRes.mul(divisor);\r\n            }\r\n            if (approxRes.isZero())\r\n                approxRes = ONE;\r\n            res = res.add(approxRes);\r\n            rem = rem.sub(approxRem);\r\n        }\r\n        return res;\r\n    };\r\n    Long.prototype.modulo = function (divisor) {\r\n        if (!isLong(divisor))\r\n            divisor = fromValue(divisor);\r\n        return this.sub(this.div(divisor).mul(divisor));\r\n    };\r\n    ;\r\n    Long.prototype.not = function () {\r\n        return fromBits(~this.low, ~this.high, this.unsigned);\r\n    };\r\n    ;\r\n    Long.prototype.and = function (other) {\r\n        if (!isLong(other))\r\n            other = fromValue(other);\r\n        return fromBits(this.low & other.low, this.high & other.high, this.unsigned);\r\n    };\r\n    Long.prototype.or = function (other) {\r\n        if (!isLong(other))\r\n            other = fromValue(other);\r\n        return fromBits(this.low | other.low, this.high | other.high, this.unsigned);\r\n    };\r\n    Long.prototype.xor = function (other) {\r\n        if (!isLong(other))\r\n            other = fromValue(other);\r\n        return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);\r\n    };\r\n    Long.prototype.shiftLeft = function (numBits) {\r\n        if (isLong(numBits))\r\n            numBits = numBits.toInt();\r\n        numBits = numBits & 63;\r\n        if (numBits === 0)\r\n            return this;\r\n        else if (numBits < 32)\r\n            return fromBits(this.low << numBits, (this.high << numBits) | (this.low >>> (32 - numBits)), this.unsigned);\r\n        else\r\n            return fromBits(0, this.low << (numBits - 32), this.unsigned);\r\n    };\r\n    Long.prototype.shiftRight = function (numBits) {\r\n        if (isLong(numBits))\r\n            numBits = numBits.toInt();\r\n        numBits = numBits & 63;\r\n        if (numBits === 0)\r\n            return this;\r\n        else if (numBits < 32)\r\n            return fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >> numBits, this.unsigned);\r\n        else\r\n            return fromBits(this.high >> (numBits - 32), this.high >= 0 ? 0 : -1, this.unsigned);\r\n    };\r\n    Long.prototype.shiftRightUnsigned = function (numBits) {\r\n        if (isLong(numBits))\r\n            numBits = numBits.toInt();\r\n        numBits = numBits & 63;\r\n        if (numBits === 0)\r\n            return this;\r\n        else {\r\n            var high = this.high;\r\n            if (numBits < 32) {\r\n                var low = this.low;\r\n                return fromBits((low >>> numBits) | (high << (32 - numBits)), high >>> numBits, this.unsigned);\r\n            }\r\n            else if (numBits === 32)\r\n                return fromBits(high, 0, this.unsigned);\r\n            else\r\n                return fromBits(high >>> (numBits - 32), 0, this.unsigned);\r\n        }\r\n    };\r\n    Long.prototype.toSigned = function () {\r\n        if (!this.unsigned)\r\n            return this;\r\n        return fromBits(this.low, this.high, false);\r\n    };\r\n    Long.prototype.toUnsigned = function () {\r\n        if (this.unsigned)\r\n            return this;\r\n        return fromBits(this.low, this.high, true);\r\n    };\r\n    Long.prototype.toBytes = function (le) {\r\n        return le ? this.toBytesLE() : this.toBytesBE();\r\n    };\r\n    Long.prototype.toBytesLE = function () {\r\n        var hi = this.high, lo = this.low;\r\n        return [\r\n            lo & 0xff,\r\n            (lo >>> 8) & 0xff,\r\n            (lo >>> 16) & 0xff,\r\n            (lo >>> 24) & 0xff,\r\n            hi & 0xff,\r\n            (hi >>> 8) & 0xff,\r\n            (hi >>> 16) & 0xff,\r\n            (hi >>> 24) & 0xff\r\n        ];\r\n    };\r\n    Long.prototype.toBytesBE = function () {\r\n        var hi = this.high, lo = this.low;\r\n        return [\r\n            (hi >>> 24) & 0xff,\r\n            (hi >>> 16) & 0xff,\r\n            (hi >>> 8) & 0xff,\r\n            hi & 0xff,\r\n            (lo >>> 24) & 0xff,\r\n            (lo >>> 16) & 0xff,\r\n            (lo >>> 8) & 0xff,\r\n            lo & 0xff\r\n        ];\r\n    };\r\n    Long.prototype[_Symbol.reflection] = function () {\r\n        return {\r\n            type: \"System.Int64\",\r\n            interfaces: [\"FSharpRecord\", \"System.IComparable\"],\r\n            properties: {\r\n                low: \"number\",\r\n                high: \"number\",\r\n                unsigned: \"boolean\"\r\n            }\r\n        };\r\n    };\r\n    return Long;\r\n}());\r\nexport { Long };\r\nvar INT_CACHE = {};\r\nvar UINT_CACHE = {};\r\nexport function isLong(obj) {\r\n    return (obj && obj instanceof Long);\r\n}\r\nexport function fromInt(value, unsigned) {\r\n    if (unsigned === void 0) { unsigned = false; }\r\n    var obj, cachedObj, cache;\r\n    if (unsigned) {\r\n        value >>>= 0;\r\n        if (cache = (0 <= value && value < 256)) {\r\n            cachedObj = UINT_CACHE[value];\r\n            if (cachedObj)\r\n                return cachedObj;\r\n        }\r\n        obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);\r\n        if (cache)\r\n            UINT_CACHE[value] = obj;\r\n        return obj;\r\n    }\r\n    else {\r\n        value |= 0;\r\n        if (cache = (-128 <= value && value < 128)) {\r\n            cachedObj = INT_CACHE[value];\r\n            if (cachedObj)\r\n                return cachedObj;\r\n        }\r\n        obj = fromBits(value, value < 0 ? -1 : 0, false);\r\n        if (cache)\r\n            INT_CACHE[value] = obj;\r\n        return obj;\r\n    }\r\n}\r\nexport function fromNumber(value, unsigned) {\r\n    if (unsigned === void 0) { unsigned = false; }\r\n    if (isNaN(value) || !isFinite(value))\r\n        return unsigned ? UZERO : ZERO;\r\n    if (unsigned) {\r\n        if (value < 0)\r\n            return UZERO;\r\n        if (value >= TWO_PWR_64_DBL)\r\n            return MAX_UNSIGNED_VALUE;\r\n    }\r\n    else {\r\n        if (value <= -TWO_PWR_63_DBL)\r\n            return MIN_VALUE;\r\n        if (value + 1 >= TWO_PWR_63_DBL)\r\n            return MAX_VALUE;\r\n    }\r\n    if (value < 0)\r\n        return fromNumber(-value, unsigned).neg();\r\n    return fromBits((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);\r\n}\r\nexport function fromBits(lowBits, highBits, unsigned) {\r\n    return new Long(lowBits, highBits, unsigned);\r\n}\r\nvar pow_dbl = Math.pow;\r\nexport function fromString(str, unsigned, radix) {\r\n    if (unsigned === void 0) { unsigned = false; }\r\n    if (radix === void 0) { radix = 10; }\r\n    if (str.length === 0)\r\n        throw Error('empty string');\r\n    if (str === \"NaN\" || str === \"Infinity\" || str === \"+Infinity\" || str === \"-Infinity\")\r\n        return ZERO;\r\n    if (typeof unsigned === 'number') {\r\n        radix = unsigned,\r\n            unsigned = false;\r\n    }\r\n    else {\r\n        unsigned = !!unsigned;\r\n    }\r\n    radix = radix || 10;\r\n    if (radix < 2 || 36 < radix)\r\n        throw RangeError('radix');\r\n    var p = str.indexOf('-');\r\n    if (p > 0)\r\n        throw Error('interior hyphen');\r\n    else if (p === 0) {\r\n        return fromString(str.substring(1), unsigned, radix).neg();\r\n    }\r\n    var radixToPower = fromNumber(pow_dbl(radix, 8));\r\n    var result = ZERO;\r\n    for (var i = 0; i < str.length; i += 8) {\r\n        var size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix);\r\n        if (size < 8) {\r\n            var power = fromNumber(pow_dbl(radix, size));\r\n            result = result.mul(power).add(fromNumber(value));\r\n        }\r\n        else {\r\n            result = result.mul(radixToPower);\r\n            result = result.add(fromNumber(value));\r\n        }\r\n    }\r\n    result.unsigned = unsigned;\r\n    return result;\r\n}\r\nexport function fromValue(val) {\r\n    if (val instanceof Long)\r\n        return val;\r\n    if (typeof val === 'number')\r\n        return fromNumber(val);\r\n    if (typeof val === 'string')\r\n        return fromString(val);\r\n    return fromBits(val.low, val.high, val.unsigned);\r\n}\r\nvar TWO_PWR_16_DBL = 1 << 16;\r\nvar TWO_PWR_24_DBL = 1 << 24;\r\nvar TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;\r\nvar TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;\r\nvar TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;\r\nvar TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);\r\nexport var ZERO = fromInt(0);\r\nexport var UZERO = fromInt(0, true);\r\nexport var ONE = fromInt(1);\r\nexport var UONE = fromInt(1, true);\r\nexport var NEG_ONE = fromInt(-1);\r\nexport var MAX_VALUE = fromBits(0xFFFFFFFF | 0, 0x7FFFFFFF | 0, false);\r\nexport var MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF | 0, 0xFFFFFFFF | 0, true);\r\nexport var MIN_VALUE = fromBits(0, 0x80000000 | 0, false);\r\n","import { create as timeSpanCreate } from \"./TimeSpan\";\r\nimport { compare as utilCompare } from \"./Util\";\r\nimport * as Long from \"./Long\";\r\nexport function minValue() {\r\n    return parse(-8640000000000000, 1);\r\n}\r\nexport function maxValue() {\r\n    return parse(8640000000000000, 1);\r\n}\r\nexport function parse(v, kind) {\r\n    if (kind == null) {\r\n        kind = typeof v == \"string\" && v.slice(-1) == \"Z\" ? 1 : 2;\r\n    }\r\n    var date = (v == null) ? new Date() : new Date(v);\r\n    if (kind === 2) {\r\n        date.kind = kind;\r\n    }\r\n    if (isNaN(date.getTime())) {\r\n        throw new Error(\"The string is not a valid Date.\");\r\n    }\r\n    return date;\r\n}\r\nexport function tryParse(v) {\r\n    try {\r\n        return [true, parse(v)];\r\n    }\r\n    catch (_err) {\r\n        return [false, minValue()];\r\n    }\r\n}\r\nexport function create(year, month, day, h, m, s, ms, kind) {\r\n    if (h === void 0) { h = 0; }\r\n    if (m === void 0) { m = 0; }\r\n    if (s === void 0) { s = 0; }\r\n    if (ms === void 0) { ms = 0; }\r\n    if (kind === void 0) { kind = 2; }\r\n    var date;\r\n    if (kind === 2) {\r\n        date = new Date(year, month - 1, day, h, m, s, ms);\r\n        date.kind = kind;\r\n    }\r\n    else {\r\n        date = new Date(Date.UTC(year, month - 1, day, h, m, s, ms));\r\n    }\r\n    if (isNaN(date.getTime())) {\r\n        throw new Error(\"The parameters describe an unrepresentable Date.\");\r\n    }\r\n    return date;\r\n}\r\nexport function now() {\r\n    return parse();\r\n}\r\nexport function utcNow() {\r\n    return parse(null, 1);\r\n}\r\nexport function today() {\r\n    return date(now());\r\n}\r\nexport function isLeapYear(year) {\r\n    return year % 4 == 0 && year % 100 != 0 || year % 400 == 0;\r\n}\r\nexport function daysInMonth(year, month) {\r\n    return month == 2\r\n        ? isLeapYear(year) ? 29 : 28\r\n        : month >= 8 ? month % 2 == 0 ? 31 : 30 : month % 2 == 0 ? 30 : 31;\r\n}\r\nexport function toUniversalTime(d) {\r\n    return d.kind === 2 ? new Date(d.getTime()) : d;\r\n}\r\nexport function toLocalTime(d) {\r\n    if (d.kind === 2) {\r\n        return d;\r\n    }\r\n    else {\r\n        var d2 = new Date(d.getTime());\r\n        d2.kind = 2;\r\n        return d2;\r\n    }\r\n}\r\nexport function timeOfDay(d) {\r\n    return timeSpanCreate(0, hour(d), minute(d), second(d), millisecond(d));\r\n}\r\nexport function date(d) {\r\n    return create(year(d), month(d), day(d), 0, 0, 0, 0, d.kind || 1);\r\n}\r\nexport function kind(d) {\r\n    return d.kind || 1;\r\n}\r\nexport function day(d) {\r\n    return d.kind === 2 ? d.getDate() : d.getUTCDate();\r\n}\r\nexport function hour(d) {\r\n    return d.kind === 2 ? d.getHours() : d.getUTCHours();\r\n}\r\nexport function millisecond(d) {\r\n    return d.kind === 2 ? d.getMilliseconds() : d.getUTCMilliseconds();\r\n}\r\nexport function minute(d) {\r\n    return d.kind === 2 ? d.getMinutes() : d.getUTCMinutes();\r\n}\r\nexport function month(d) {\r\n    return (d.kind === 2 ? d.getMonth() : d.getUTCMonth()) + 1;\r\n}\r\nexport function second(d) {\r\n    return d.kind === 2 ? d.getSeconds() : d.getUTCSeconds();\r\n}\r\nexport function year(d) {\r\n    return d.kind === 2 ? d.getFullYear() : d.getUTCFullYear();\r\n}\r\nexport function dayOfWeek(d) {\r\n    return d.kind === 2 ? d.getDay() : d.getUTCDay();\r\n}\r\nexport function ticks(d) {\r\n    return Long.fromNumber(d.getTime())\r\n        .add(62135596800000)\r\n        .sub(d.kind == 2 ? d.getTimezoneOffset() * 60 * 1000 : 0)\r\n        .mul(10000);\r\n}\r\nexport function toBinary(d) {\r\n    return ticks(d);\r\n}\r\nexport function dayOfYear(d) {\r\n    var _year = year(d);\r\n    var _month = month(d);\r\n    var _day = day(d);\r\n    for (var i = 1; i < _month; i++)\r\n        _day += daysInMonth(_year, i);\r\n    return _day;\r\n}\r\nexport function add(d, ts) {\r\n    return parse(d.getTime() + ts, d.kind || 1);\r\n}\r\nexport function addDays(d, v) {\r\n    return parse(d.getTime() + v * 86400000, d.kind || 1);\r\n}\r\nexport function addHours(d, v) {\r\n    return parse(d.getTime() + v * 3600000, d.kind || 1);\r\n}\r\nexport function addMinutes(d, v) {\r\n    return parse(d.getTime() + v * 60000, d.kind || 1);\r\n}\r\nexport function addSeconds(d, v) {\r\n    return parse(d.getTime() + v * 1000, d.kind || 1);\r\n}\r\nexport function addMilliseconds(d, v) {\r\n    return parse(d.getTime() + v, d.kind || 1);\r\n}\r\nexport function addTicks(d, t) {\r\n    return parse(Long.fromNumber(d.getTime()).add(t.div(10000)).toNumber(), d.kind || 1);\r\n}\r\nexport function addYears(d, v) {\r\n    var newMonth = month(d);\r\n    var newYear = year(d) + v;\r\n    var _daysInMonth = daysInMonth(newYear, newMonth);\r\n    var newDay = Math.min(_daysInMonth, day(d));\r\n    return create(newYear, newMonth, newDay, hour(d), minute(d), second(d), millisecond(d), d.kind || 1);\r\n}\r\nexport function addMonths(d, v) {\r\n    var newMonth = month(d) + v;\r\n    var newMonth_ = 0;\r\n    var yearOffset = 0;\r\n    if (newMonth > 12) {\r\n        newMonth_ = newMonth % 12;\r\n        yearOffset = Math.floor(newMonth / 12);\r\n        newMonth = newMonth_;\r\n    }\r\n    else if (newMonth < 1) {\r\n        newMonth_ = 12 + newMonth % 12;\r\n        yearOffset = Math.floor(newMonth / 12) + (newMonth_ == 12 ? -1 : 0);\r\n        newMonth = newMonth_;\r\n    }\r\n    var newYear = year(d) + yearOffset;\r\n    var _daysInMonth = daysInMonth(newYear, newMonth);\r\n    var newDay = Math.min(_daysInMonth, day(d));\r\n    return create(newYear, newMonth, newDay, hour(d), minute(d), second(d), millisecond(d), d.kind || 1);\r\n}\r\nexport function subtract(d, that) {\r\n    return typeof that == \"number\"\r\n        ? parse(d.getTime() - that, d.kind || 1)\r\n        : d.getTime() - that.getTime();\r\n}\r\nexport function toLongDateString(d) {\r\n    return d.toDateString();\r\n}\r\nexport function toShortDateString(d) {\r\n    return d.toLocaleDateString();\r\n}\r\nexport function toLongTimeString(d) {\r\n    return d.toLocaleTimeString();\r\n}\r\nexport function toShortTimeString(d) {\r\n    return d.toLocaleTimeString().replace(/:\\d\\d(?!:)/, \"\");\r\n}\r\nexport function equals(d1, d2) {\r\n    return d1.getTime() == d2.getTime();\r\n}\r\nexport function compare(x, y) {\r\n    return utilCompare(x, y);\r\n}\r\nexport function compareTo(x, y) {\r\n    return utilCompare(x, y);\r\n}\r\nexport function op_Addition(x, y) {\r\n    return add(x, y);\r\n}\r\nexport function op_Subtraction(x, y) {\r\n    return subtract(x, y);\r\n}\r\n","import { toString } from \"./Util\";\r\nimport { getRestParams } from \"./Util\";\r\nimport { escape } from \"./RegExp\";\r\nimport { second } from \"./Date\";\r\nimport { minute } from \"./Date\";\r\nimport { hour } from \"./Date\";\r\nimport { day } from \"./Date\";\r\nimport { month } from \"./Date\";\r\nimport { year } from \"./Date\";\r\nvar fsFormatRegExp = /(^|[^%])%([0+ ]*)(-?\\d+)?(?:\\.(\\d+))?(\\w)/;\r\nvar formatRegExp = /\\{(\\d+)(,-?\\d+)?(?:\\:(.+?))?\\}/g;\r\nvar StringComparison = {\r\n    CurrentCulture: 0,\r\n    CurrentCultureIgnoreCase: 1,\r\n    InvariantCulture: 2,\r\n    InvariantCultureIgnoreCase: 3,\r\n    Ordinal: 4,\r\n    OrdinalIgnoreCase: 5,\r\n};\r\nfunction cmp(x, y, ic) {\r\n    function isIgnoreCase(i) {\r\n        return i === true ||\r\n            i === StringComparison.CurrentCultureIgnoreCase ||\r\n            i === StringComparison.InvariantCultureIgnoreCase ||\r\n            i === StringComparison.OrdinalIgnoreCase;\r\n    }\r\n    function isOrdinal(i) {\r\n        return i === StringComparison.Ordinal ||\r\n            i === StringComparison.OrdinalIgnoreCase;\r\n    }\r\n    if (x == null)\r\n        return y == null ? 0 : -1;\r\n    if (y == null)\r\n        return 1;\r\n    if (isOrdinal(ic)) {\r\n        if (isIgnoreCase(ic)) {\r\n            x = x.toLowerCase();\r\n            y = y.toLowerCase();\r\n        }\r\n        return (x === y) ? 0 : (x < y ? -1 : 1);\r\n    }\r\n    else {\r\n        if (isIgnoreCase(ic)) {\r\n            x = x.toLocaleLowerCase();\r\n            y = y.toLocaleLowerCase();\r\n        }\r\n        return x.localeCompare(y);\r\n    }\r\n}\r\nexport function compare() {\r\n    var args = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        args[_i] = arguments[_i];\r\n    }\r\n    switch (args.length) {\r\n        case 2: return cmp(args[0], args[1], false);\r\n        case 3: return cmp(args[0], args[1], args[2]);\r\n        case 4: return cmp(args[0], args[1], args[2] === true);\r\n        case 5: return cmp(args[0].substr(args[1], args[4]), args[2].substr(args[3], args[4]), false);\r\n        case 6: return cmp(args[0].substr(args[1], args[4]), args[2].substr(args[3], args[4]), args[5]);\r\n        case 7: return cmp(args[0].substr(args[1], args[4]), args[2].substr(args[3], args[4]), args[5] === true);\r\n        default: throw new Error(\"String.compare: Unsupported number of parameters\");\r\n    }\r\n}\r\nexport function compareTo(x, y) {\r\n    return cmp(x, y, false);\r\n}\r\nexport function indexOfAny(str, anyOf) {\r\n    var args = [];\r\n    for (var _i = 2; _i < arguments.length; _i++) {\r\n        args[_i - 2] = arguments[_i];\r\n    }\r\n    if (str == null || str === \"\")\r\n        return -1;\r\n    var startIndex = (args.length > 0) ? args[0] : 0;\r\n    if (startIndex < 0)\r\n        throw new Error(\"String.indexOfAny: Start index cannot be negative\");\r\n    var length = (args.length > 1) ? args[1] : str.length - startIndex;\r\n    if (length < 0)\r\n        throw new Error(\"String.indexOfAny: Length cannot be negative\");\r\n    if (length > str.length - startIndex)\r\n        throw new Error(\"String.indexOfAny: Invalid startIndex and length\");\r\n    str = str.substr(startIndex, length);\r\n    for (var _a = 0, anyOf_1 = anyOf; _a < anyOf_1.length; _a++) {\r\n        var c = anyOf_1[_a];\r\n        var index = str.indexOf(c);\r\n        if (index > -1)\r\n            return index + startIndex;\r\n    }\r\n    return -1;\r\n}\r\nfunction toHex(value) {\r\n    return value < 0\r\n        ? \"ff\" + (16777215 - (Math.abs(value) - 1)).toString(16)\r\n        : value.toString(16);\r\n}\r\nexport function fsFormat(str) {\r\n    var args = [];\r\n    for (var _i = 1; _i < arguments.length; _i++) {\r\n        args[_i - 1] = arguments[_i];\r\n    }\r\n    var _cont;\r\n    function isObject(x) {\r\n        return x !== null && typeof x === \"object\" && !(x instanceof Number) && !(x instanceof String) && !(x instanceof Boolean);\r\n    }\r\n    function formatOnce(str, rep) {\r\n        return str.replace(fsFormatRegExp, function (_, prefix, flags, pad, precision, format) {\r\n            switch (format) {\r\n                case \"f\":\r\n                case \"F\":\r\n                    rep = rep.toFixed(precision || 6);\r\n                    break;\r\n                case \"g\":\r\n                case \"G\":\r\n                    rep = rep.toPrecision(precision);\r\n                    break;\r\n                case \"e\":\r\n                case \"E\":\r\n                    rep = rep.toExponential(precision);\r\n                    break;\r\n                case \"O\":\r\n                    rep = toString(rep);\r\n                    break;\r\n                case \"A\":\r\n                    try {\r\n                        rep = JSON.stringify(rep, function (k, v) {\r\n                            return v && v[Symbol.iterator] && !Array.isArray(v) && isObject(v) ? Array.from(v)\r\n                                : v && typeof v.ToString === \"function\" ? toString(v) : v;\r\n                        });\r\n                    }\r\n                    catch (err) {\r\n                        rep = \"{\" + Object.getOwnPropertyNames(rep).map(function (k) { return k + \": \" + String(rep[k]); }).join(\", \") + \"}\";\r\n                    }\r\n                    break;\r\n                case \"x\":\r\n                    rep = toHex(Number(rep));\r\n                    break;\r\n                case \"X\":\r\n                    rep = toHex(Number(rep)).toUpperCase();\r\n                    break;\r\n            }\r\n            var plusPrefix = flags.indexOf(\"+\") >= 0 && parseInt(rep) >= 0;\r\n            if (!isNaN(pad = parseInt(pad))) {\r\n                var ch = pad >= 0 && flags.indexOf(\"0\") >= 0 ? \"0\" : \" \";\r\n                rep = padLeft(rep, Math.abs(pad) - (plusPrefix ? 1 : 0), ch, pad < 0);\r\n            }\r\n            var once = prefix + (plusPrefix ? \"+\" + rep : rep);\r\n            return once.replace(/%/g, \"%%\");\r\n        });\r\n    }\r\n    function makeFn(str) {\r\n        return function (rep) {\r\n            var str2 = formatOnce(str, rep);\r\n            return fsFormatRegExp.test(str2)\r\n                ? makeFn(str2) : _cont(str2.replace(/%%/g, \"%\"));\r\n        };\r\n    }\r\n    if (args.length === 0) {\r\n        return function (cont) {\r\n            _cont = cont;\r\n            return fsFormatRegExp.test(str) ? makeFn(str) : _cont(str);\r\n        };\r\n    }\r\n    else {\r\n        for (var i = 0; i < args.length; i++) {\r\n            str = formatOnce(str, args[i]);\r\n        }\r\n        return str.replace(/%%/g, \"%\");\r\n    }\r\n}\r\nexport function format(str) {\r\n    var args = [];\r\n    for (var _i = 1; _i < arguments.length; _i++) {\r\n        args[_i - 1] = arguments[_i];\r\n    }\r\n    return str.replace(formatRegExp, function (match, idx, pad, format) {\r\n        var rep = args[idx], padSymbol = \" \";\r\n        if (typeof rep === \"number\") {\r\n            switch ((format || \"\").substring(0, 1)) {\r\n                case \"f\":\r\n                case \"F\":\r\n                    rep = format.length > 1 ? rep.toFixed(format.substring(1)) : rep.toFixed(2);\r\n                    break;\r\n                case \"g\":\r\n                case \"G\":\r\n                    rep = format.length > 1 ? rep.toPrecision(format.substring(1)) : rep.toPrecision();\r\n                    break;\r\n                case \"e\":\r\n                case \"E\":\r\n                    rep = format.length > 1 ? rep.toExponential(format.substring(1)) : rep.toExponential();\r\n                    break;\r\n                case \"p\":\r\n                case \"P\":\r\n                    rep = (format.length > 1 ? (rep * 100).toFixed(format.substring(1)) : (rep * 100).toFixed(2)) + \" %\";\r\n                    break;\r\n                case \"x\":\r\n                    rep = toHex(Number(rep));\r\n                    break;\r\n                case \"X\":\r\n                    rep = toHex(Number(rep)).toUpperCase();\r\n                    break;\r\n                default:\r\n                    var m = /^(0+)(\\.0+)?$/.exec(format);\r\n                    if (m != null) {\r\n                        var decs = 0;\r\n                        if (m[2] != null)\r\n                            rep = rep.toFixed(decs = m[2].length - 1);\r\n                        pad = \",\" + (m[1].length + (decs ? decs + 1 : 0)).toString();\r\n                        padSymbol = \"0\";\r\n                    }\r\n                    else if (format) {\r\n                        rep = format;\r\n                    }\r\n            }\r\n        }\r\n        else if (rep instanceof Date) {\r\n            if (format.length === 1) {\r\n                switch (format) {\r\n                    case \"D\":\r\n                        rep = rep.toDateString();\r\n                        break;\r\n                    case \"T\":\r\n                        rep = rep.toLocaleTimeString();\r\n                        break;\r\n                    case \"d\":\r\n                        rep = rep.toLocaleDateString();\r\n                        break;\r\n                    case \"t\":\r\n                        rep = rep.toLocaleTimeString().replace(/:\\d\\d(?!:)/, \"\");\r\n                        break;\r\n                    case \"o\":\r\n                    case \"O\":\r\n                        if (rep.kind === 2) {\r\n                            var offset = rep.getTimezoneOffset() * -1;\r\n                            rep = format(\"{0:yyyy-MM-dd}T{0:HH:mm}:{1:00.000}{2}{3:00}:{4:00}\", rep, second(rep), offset >= 0 ? \"+\" : \"-\", ~~(offset / 60), offset % 60);\r\n                        }\r\n                        else {\r\n                            rep = rep.toISOString();\r\n                        }\r\n                }\r\n            }\r\n            else {\r\n                rep = format.replace(/\\w+/g, function (match2) {\r\n                    var rep2 = match2;\r\n                    switch (match2.substring(0, 1)) {\r\n                        case \"y\":\r\n                            rep2 = match2.length < 4 ? year(rep) % 100 : year(rep);\r\n                            break;\r\n                        case \"h\":\r\n                            rep2 = rep.getHours() > 12 ? hour(rep) % 12 : hour(rep);\r\n                            break;\r\n                        case \"M\":\r\n                            rep2 = month(rep);\r\n                            break;\r\n                        case \"d\":\r\n                            rep2 = day(rep);\r\n                            break;\r\n                        case \"H\":\r\n                            rep2 = hour(rep);\r\n                            break;\r\n                        case \"m\":\r\n                            rep2 = minute(rep);\r\n                            break;\r\n                        case \"s\":\r\n                            rep2 = second(rep);\r\n                            break;\r\n                    }\r\n                    if (rep2 !== match2 && rep2 < 10 && match2.length > 1) {\r\n                        rep2 = \"0\" + rep2;\r\n                    }\r\n                    return rep2;\r\n                });\r\n            }\r\n        }\r\n        if (!isNaN(pad = parseInt((pad || \"\").substring(1)))) {\r\n            rep = padLeft(rep, Math.abs(pad), padSymbol, pad < 0);\r\n        }\r\n        return rep;\r\n    });\r\n}\r\nexport function endsWith(str, search) {\r\n    var idx = str.lastIndexOf(search);\r\n    return idx >= 0 && idx == str.length - search.length;\r\n}\r\nexport function initialize(n, f) {\r\n    if (n < 0)\r\n        throw new Error(\"String length must be non-negative\");\r\n    var xs = new Array(n);\r\n    for (var i = 0; i < n; i++)\r\n        xs[i] = f(i);\r\n    return xs.join(\"\");\r\n}\r\nexport function insert(str, startIndex, value) {\r\n    if (startIndex < 0 || startIndex > str.length) {\r\n        throw new Error(\"startIndex is negative or greater than the length of this instance.\");\r\n    }\r\n    return str.substring(0, startIndex) + value + str.substring(startIndex);\r\n}\r\nexport function isNullOrEmpty(str) {\r\n    return typeof str !== \"string\" || str.length == 0;\r\n}\r\nexport function isNullOrWhiteSpace(str) {\r\n    return typeof str !== \"string\" || /^\\s*$/.test(str);\r\n}\r\nexport function join(delimiter, xs) {\r\n    xs = typeof xs == \"string\" ? getRestParams(arguments, 1) : xs;\r\n    return (Array.isArray(xs) ? xs : Array.from(xs)).join(delimiter);\r\n}\r\nexport function newGuid() {\r\n    var uuid = \"\";\r\n    for (var i = 0; i < 32; i++) {\r\n        var random = Math.random() * 16 | 0;\r\n        if (i === 8 || i === 12 || i === 16 || i === 20)\r\n            uuid += \"-\";\r\n        uuid += (i === 12 ? 4 : i === 16 ? random & 3 | 8 : random).toString(16);\r\n    }\r\n    return uuid;\r\n}\r\nexport function padLeft(str, len, ch, isRight) {\r\n    ch = ch || \" \";\r\n    str = String(str);\r\n    len = len - str.length;\r\n    for (var i = -1; ++i < len;)\r\n        str = isRight ? str + ch : ch + str;\r\n    return str;\r\n}\r\nexport function padRight(str, len, ch) {\r\n    return padLeft(str, len, ch, true);\r\n}\r\nexport function remove(str, startIndex, count) {\r\n    if (startIndex >= str.length) {\r\n        throw new Error(\"startIndex must be less than length of string\");\r\n    }\r\n    if (typeof count === \"number\" && (startIndex + count) > str.length) {\r\n        throw new Error(\"Index and count must refer to a location within the string.\");\r\n    }\r\n    return str.slice(0, startIndex) + (typeof count === \"number\" ? str.substr(startIndex + count) : \"\");\r\n}\r\nexport function replace(str, search, replace) {\r\n    return str.replace(new RegExp(escape(search), \"g\"), replace);\r\n}\r\nexport function replicate(n, x) {\r\n    return initialize(n, function () { return x; });\r\n}\r\nexport function split(str, splitters, count, removeEmpty) {\r\n    count = typeof count == \"number\" ? count : null;\r\n    removeEmpty = typeof removeEmpty == \"number\" ? removeEmpty : null;\r\n    if (count < 0)\r\n        throw new Error(\"Count cannot be less than zero\");\r\n    if (count === 0)\r\n        return [];\r\n    splitters = Array.isArray(splitters) ? splitters : getRestParams(arguments, 1);\r\n    splitters = splitters.map(function (x) { return escape(x); });\r\n    splitters = splitters.length > 0 ? splitters : [\" \"];\r\n    var m;\r\n    var i = 0;\r\n    var splits = [];\r\n    var reg = new RegExp(splitters.join(\"|\"), \"g\");\r\n    while ((count == null || count > 1) && (m = reg.exec(str)) !== null) {\r\n        if (!removeEmpty || (m.index - i) > 0) {\r\n            count = count != null ? count - 1 : count;\r\n            splits.push(str.substring(i, m.index));\r\n        }\r\n        i = reg.lastIndex;\r\n    }\r\n    if (!removeEmpty || (str.length - i) > 0)\r\n        splits.push(str.substring(i));\r\n    return splits;\r\n}\r\nexport function trim(str, side) {\r\n    var chars = [];\r\n    for (var _i = 2; _i < arguments.length; _i++) {\r\n        chars[_i - 2] = arguments[_i];\r\n    }\r\n    if (side == \"both\" && chars.length == 0)\r\n        return str.trim();\r\n    if (side == \"start\" || side == \"both\") {\r\n        var reg = chars.length == 0 ? /^\\s+/ : new RegExp(\"^[\" + escape(chars.join(\"\")) + \"]+\");\r\n        str = str.replace(reg, \"\");\r\n    }\r\n    if (side == \"end\" || side == \"both\") {\r\n        var reg = chars.length == 0 ? /\\s+$/ : new RegExp(\"[\" + escape(chars.join(\"\")) + \"]+$\");\r\n        str = str.replace(reg, \"\");\r\n    }\r\n    return str;\r\n}\r\n","module FsHtml\n\ntype Html =\n   | Elem of string * Html list\n   | Attr of string * string\n   | Text of string\n   with\n   static member toString elem =\n      let rec toString indent elem =\n         let spaces = String.replicate indent \" \"\n         match elem with\n         | Attr(name,value) -> name+\"=\\\"\"+value+\"\\\"\"\n         | Elem(tag, [Text s]) ->\n            spaces+\"<\"+tag+\">\"+s+\"</\"+tag+\">\\r\\n\"\n         | Elem(tag, content) ->\n            let isAttr = function Attr _ -> true | _ -> false\n            let attrs, elems = content |> List.partition isAttr\n            let attrs =         \n               if attrs = [] then \"\"\n               else \" \" + String.concat \" \" [for attr in attrs -> toString 0 attr]\n            match elems with\n            | [] -> spaces+\"<\"+tag+attrs+\"/>\\r\\n\"\n            | _ ->\n               spaces+\"<\"+tag+attrs+\">\\r\\n\"+\n                  String.concat \"\" [for e in elems -> toString (indent+1) e] +\n                     spaces+\"</\"+tag+\">\\r\\n\"\n         | Text(text) ->            \n            spaces + text + \"\\r\\n\"\n      toString 0 elem\n   override this.ToString() = Html.toString this\n\nlet elem tag content = Elem(tag,content)\nlet html = elem \"html\"\nlet head = elem \"head\"\nlet title = elem \"title\"\nlet style = elem \"style\"\nlet body = elem \"body\"\nlet div = elem \"div\"\nlet br = elem \"br\"\nlet section = elem \"section\"\nlet span = elem \"span\"\nlet table = elem \"table\"\nlet thead = elem \"thead\"\nlet tbody = elem \"tbody\"\nlet tfoot = elem \"tfoot\"\nlet img = elem \"img\"\nlet map = elem \"map\"\nlet area = elem \"area\"\nlet p = elem \"p\"\nlet a = elem \"a\"\nlet tr = elem \"tr\"\nlet td = elem \"td\"\nlet th = elem \"th\"\nlet ul = elem \"ul\"\nlet li = elem \"li\"\nlet h1 = elem \"h1\"\nlet h2 = elem \"h1\"\nlet h3 = elem \"h1\"\nlet h4 = elem \"h1\"\nlet strong = elem \"strong\"\nlet (~%) s = [Text(s.ToString())]\nlet (%=) name value = Attr(name,value)\n","﻿namespace Common\n\nmodule Error =\n    \n    /// Error monad. Ok: valid result. Err: error string plus error value (line number).\n    type Error<'a> =\n        | Ok of 'a\n        | Err of int*string\n\n    /// Wrap function in error monad. Function must return error.\n    let wrapErr f x =\n        match x with\n        | Ok(arg) -> f arg\n        | Err(i,s) -> Err(i,s)","﻿// The interpreter, this reads instructions and calls the appropriate function.\n\nnamespace Interpret\nmodule Interpreter =\n    \n    open Common.State\n    open Common.Error\n    open Common.Types\n\n    /// Calls functions on map of (memloc * instructions).\n    let rec interpret state instr =\n        match Map.tryFind (readPC state) instr with\n        | Some(Instr(l,f)) -> interpret (incPC (f state)) instr\n        | Some(Terminate(l)) -> Ok(l,state)\n        | Some(LabelRef(_)) -> Err(0,\"Unresolved label (branch/adr) - this should have been resolved in the parser.\")\n        | Some(EndRef(_)) -> Err(0,\"Unresolved termination - this should have been resolved in the parser.\")\n        | None -> Err(0,sprintf \"Instruction does not exist at address %A.\" (readPC state))\n\n    /// Runs ONLY the instruction pointed to by the PC in state.\n    let interpretLine state instr =\n        match Map.tryFind (readPC state) instr with\n        | Some(Instr(l,f)) -> Ok(l, incPC (f state))\n        | Some(Terminate(l)) -> Ok(l,state)\n        | Some(LabelRef(_)) -> Err(0,\"Unresolved label (branch/adr) - this should have been resolved in the parser.\")\n        | Some(EndRef(_)) -> Err(0,\"Unresolved termination - this should have been resolved in the parser.\")\n        | None -> Err(0,sprintf \"Instruction does not exist at address %A.\" (readPC state))","﻿// This module contains the error messages used in the parser.\n\nnamespace Parse\nmodule ParseError =\n\n    open Common.Error\n    open Common.Types\n\n    /// Return first 5 elements of list.\n    let errorList lst =\n        let rec addToStr lst n =\n            match n < 10 with\n            | true -> match lst with\n                      | h::t -> (sprintf \"%A\" h) + \"; \" + (addToStr t (n+1))\n                      | [] -> \"\"\n            | false -> \"\"\n        addToStr lst 0\n\n    /// Register range out of bounds.\n    let invalidRegRange l = Err(l,\"Register range invalid. Must be a continuous sequence of registers. e.g. {R1-R3, R5, R8-R11}\")\n\n    /// Error token - an unrecognised string.\n    let invalidToken l s = Err(l,sprintf \"Invalid input string: %s. This might be a typo, a non-existent register or an invalid label.\" s)\n\n    /// Valid token which appears unexpectedly. Prints the following 5 tokens to give context\n    let unexpectedToken l t lst = Err(l,sprintf \"Unexpected token: %A. Followed by: %s. Check the supported arguments for the instruction.\" t (errorList lst))\n\n    /// Attempt to access label(symbol) which is undefined.\n    let undefinedLabel l s = Err(l,sprintf \"Label undefined: %s. It is being referenced but doesn't point anywhere. This might be a typo.\" s)\n\n    /// 12-bit immediate value incorrect. Must be 8-bit value shifted by 5 bits.\n    let invalidImmRange l i = Err(l,sprintf \"12-bit Immediate value out of range: %x. Must be a 8-bit value, rotated by an even 5-bit value.\" i)\n\n    /// 5-bit shift value out of range.\n    let invalidShiftImmRange l i z =\n        let (hi,lo) = match z with\n                      | T_ASR -> (1,32)\n                      | T_LSL -> (0,31)\n                      | T_LSR -> (1,32)\n                      | T_ROR -> (1,31)\n                      | T_RRX -> (1,1)\n        Err(l,sprintf \"Shift immediate value out of range: %d. Must be between %d and %d\" i lo hi)\n\n    /// Shift match ends unexpectedly.\n    let invalidShiftMatch l = Err(l,sprintf \"Shift matches improperly.\")\n\n    /// 12-bit immediate value for memory offset incorrect.\n    let invalidMemOffsetRange l i = Err(l,sprintf \"12-bit Immediate offset value out of range: %x. Must be between -4095 and +4095.\" i)","﻿// This file defines Enums that appear in the tokeniser and are used in interpretation.\n\nnamespace Common\n\nmodule Types =\n\n    open Error\n    open State\n    \n    /// Shift tokens.\n    type shiftOp =\n        | T_ASR\n        | T_LSL\n        | T_LSR\n        | T_ROR\n        | T_RRX\n\n    /// Load/Store Multiple tokens.\n    type stackOrder =\n        | S_IA\n        | S_IB\n        | S_DA\n        | S_DB\n\n    /// Operand type tokens.\n    type opType =\n        | T_I\n        | T_R\n\n    /// Wrapper for instructions, including unresolved references.\n    type Instruction = \n        | LabelRef of (Map<string,int> -> Error<Instruction>)\n        | EndRef of (int -> Instruction)\n        // Instruction contains the line number in addition to the function that transforms the state.\n        | Instr of int*(StateHandle -> StateHandle)\n        | Terminate of int","﻿// This module contains functions to run the ARMv4 instruction set.\n // Mark down document: https://github.com/coopersimon/HLP/blob/dev_16_03/Documentation/Interfaces/ARMv4.md\n // Not all instructions supported by the following functions are support by VISUAL. \n // VISUAL supports : https://web.archive.org/web/20160831113526/http://salmanarif.bitbucket.org/visual/supported_instructions.html\n\nnamespace Interpret\nmodule ARMv4 =\n    open Common.State\n    open Common.Types\n    open Parse.Tokeniser\n\n    let shiftI inst r n state = \n        let m = n%32\n        match inst with \n        |T_LSL -> if n>=32 then 0 else (readReg r state)<<<n\n        |T_LSR -> if n>=32 then 0 else int((uint32(readReg r state))>>>n)\n        |T_ASR -> if n>=32 then (if (readReg r state)>0 then 0 else -1) else (readReg r state)>>>n\n        |T_ROR -> if n=0 then readReg r state else int(((uint32(readReg r state))>>>m) + ((uint32(readReg r state))<<<(32-m)))\n        |T_RRX -> match (readCFlag state) with\n                    |true -> (readReg r state)>>>1 + 1<<<31\n                    |false -> (readReg r state)>>>1\n\n    let shiftR inst r rn state =\n        let m = (readReg rn state)&&&255 //least significant byte\n        shiftI inst r m state \n\n    let shiftSetCI s inst r n state = //should work for range n=[0,255]\n        if n=0\n        then state //don't write carry if no shift or rotate done\n        else if s\n             then match inst with\n                  |T_LSL -> if n<=32 \n                            then writeCFlag (((readReg r state)>>>(32-n))%2<>0) state \n                            else writeCFlag false state\n                  |T_LSR -> if n<=32 \n                            then writeCFlag (((readReg r state)>>>(n-1))%2<>0) state \n                            else writeCFlag false state \n                  |T_ASR -> if n<=32 \n                            then writeCFlag (((readReg r state)>>>(n-1))%2<>0) state \n                            else if n>0 \n                                 then writeCFlag false state\n                                 else writeCFlag true state\n                  |T_ROR -> writeCFlag (((readReg r state)>>>((n%32)-1))%2<>0) state\n                  |T_RRX -> writeCFlag ((readReg r state)%2<>0) state\n             else state //don't write carry if no S specified\n\n    let shiftSetCR s inst r rn state = \n        let m = (readReg rn state)&&&255 //least significant byte\n        shiftSetCI s inst r m state\n\n//functions to set flags\n    //set N and Z flags for all cases\n    let setNZ result state =\n        state |> writeNFlag (result<0) |> writeZFlag (result=0)\n\n    //set C for arithmetic ADD, ADC, SUB, SBC, RSB and RSC cases (Note: in1 and in2 are int64)\n    let setC in1 in2 state = \n        writeCFlag (((in1+in2)>>>32)%2L<>0L) state\n\n    //this function converts an int32 to an int64 without sign extension.\n    let conv64 i = (int64 i)&&&(4294967295L)\n\n    //set V for arithmetic ADD, ADC, SUB, SBC, RSB and RSC cases (Note: in1 and in2 are int)\n    let setV in1 in2 state =   \n        let cin = ((conv64(in1*2)+conv64(in2*2))>>>32)%2L\n        let cout = (((conv64 in1)+(conv64 in2))>>>32)%2L\n        writeVFlag (cin<>cout) state\n     \n//MOV and MVN (DONE)\n//http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0068b/CIHCDBCA.html\n\n    //write op2 to r\n    let movI c s rd i state = //if s: sets N and Z flags only\n        match (c state, s) with\n        | (true, true) -> state |> setNZ i |> writeReg rd i \n        | (true, false) -> writeReg rd i state\n        | _ -> state\n\n    let movR c s rd rm rsinst nORrn rstype state = //if s: sets N, Z (and C) flags only \n        let op2 =\n            match rstype with\n            |T_I -> shiftI rsinst rm nORrn state \n            |T_R -> shiftR rsinst rm nORrn state \n        if c state\n        then match rstype with\n             |T_I -> shiftSetCI s rsinst rm nORrn state |> movI c s rd op2 \n             |T_R -> shiftSetCR s rsinst rm nORrn state |> movI c s rd op2 \n        else state\n        \n    //write bitwise not of op2 to r\n    let mvnI c s rd i state = //if s: sets N and Z flags only\n        movI c s rd ~~~i state \n\n    let mvnR c s rd rm rsinst nORrn rstype state = //if s: sets N, Z (and C) flags only \n        let op2 =\n            match rstype with\n            |T_I -> shiftI rsinst rm nORrn state \n            |T_R -> shiftR rsinst rm nORrn state \n        if c state \n        then match rstype with\n             |T_I -> shiftSetCI s rsinst rm nORrn state |> mvnI c s rd op2 \n             |T_R -> shiftSetCR s rsinst rm nORrn state |> mvnI c s rd op2     \n        else state\n\n//ADD, ADC, SUB, SBC, RSB and RSC (DONE)\n//http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0068b/CIHCJFJG.html\n\n    //write rn+op2 to rd\n    let addI c s rd rn i state = //if s: sets N, Z, C, V flags\n        match (c state, s) with \n        | (true, true) -> state\n                          |> setNZ ((readReg rn state)+i) \n                          |> setC (conv64 (readReg rn state)) (conv64 i)\n                          |> setV (readReg rn state) (i) \n                          |> writeReg rd ((readReg rn state)+i)\n        | (true, false) -> writeReg rd ((readReg rn state)+i) state\n        | _ -> state\n    \n    let addR c s rd rn rm rsinst nORrn rstype state = //if s: sets N, Z, C, V flags\n        let op2 =\n            match rstype with\n            |T_I -> shiftI rsinst rm nORrn state \n            |T_R -> shiftR rsinst rm nORrn state \n        addI c s rd rn op2 state\n\n    //write rn+op2+carry to rd\n    let adcI c s rd rn i state = //if s: sets N, Z, C, V flags\n        match (c state, s, readCFlag state) with \n        | (true, true, false) -> state\n                                 |> setNZ ((readReg rn state)+i) \n                                 |> setC (conv64 (readReg rn state)) (conv64 i)\n                                 |> setV (readReg rn state) (i) \n                                 |> writeReg rd ((readReg rn state)+i) \n        | (true, true, true) ->  state\n                                 |> setNZ ((readReg rn state)+i+1) \n                                 |> setC (conv64 (readReg rn state)) ((conv64 i)+1L)\n                                 |> setV (readReg rn state) (i+1) \n                                 |> writeReg rd ((readReg rn state)+i+1) \n        | (true, false, false) -> writeReg rd ((readReg rn state)+i) state\n        | (true, false, true) -> writeReg rd ((readReg rn state)+i+1) state\n        | _ -> state\n    \n    let adcR c s rd rn rm rsinst nORrn rstype state = //if s: sets N, Z, C, V flags\n        let op2 =\n            match rstype with\n            |T_I -> shiftI rsinst rm nORrn state \n            |T_R -> shiftR rsinst rm nORrn state \n        adcI c s rd rn op2 state\n    \n    //write rn-op2 to rd\n    let subI c s rd rn i state = //if s: sets N, Z, C, V flags\n        match (c state, s) with \n        | (true, true) -> state\n                          |> setNZ ((readReg rn state)-i) \n                          |> setC (conv64 (readReg rn state)) ((conv64 ~~~i)+1L)\n                          |> setV (readReg rn state) (-i)\n                          |> writeReg rd ((readReg rn state)-i)\n        | (true, false) -> writeReg rd ((readReg rn state)-i) state\n        | _ -> state\n    \n    let subR c s rd rn rm rsinst nORrn rstype state = //if s: sets N, Z, C, V flags\n        let op2 =\n            match rstype with\n            |T_I -> shiftI rsinst rm nORrn state \n            |T_R -> shiftR rsinst rm nORrn state \n        subI c s rd rn op2 state\n\n    //write rn-op2-!carry to rd\n    let sbcI c s rd rn i state = //if s: sets N, Z, C, V flags\n        match (c state, s, readCFlag state) with \n        | (true, true, true) -> state\n                                |> setNZ ((readReg rn state)-i)\n                                |> setC (conv64 (readReg rn state)) ((conv64 ~~~i)+1L) \n                                |> setV (readReg rn state) (-i) \n                                |> writeReg rd ((readReg rn state)-i) \n        | (true, true, false) -> state\n                                |> setNZ ((readReg rn state)-i-1) \n                                |> setC (conv64 (readReg rn state)) ((conv64 ~~~i)) \n                                |> setV (readReg rn state) (-i-1) \n                                |> writeReg rd ((readReg rn state)-i-1) \n        | (true, false, true) -> writeReg rd ((readReg rn state)-i) state\n        | (true, false, false) -> writeReg rd ((readReg rn state)-i-1) state\n        | _ -> state\n    \n    let sbcR c s rd rn rm rsinst nORrn rstype state = //if s: sets N, Z, C, V flags\n        let op2 =\n            match rstype with\n            |T_I -> shiftI rsinst rm nORrn state \n            |T_R -> shiftR rsinst rm nORrn state \n        sbcI c s rd rn op2 state\n\n    //write op2-rn to rd\n    let rsbI c s rd rn i state = //if s: sets N, Z, C, V flags\n        match (c state, s) with \n        | (true, true) -> state\n                          |> setNZ (i-(readReg rn state))\n                          |> setC (conv64 ~~~(readReg rn state)+1L) (conv64 i) \n                          |> setV (-(readReg rn state)) (i) \n                          |> writeReg rd (i-(readReg rn state)) \n        | (true, false) -> writeReg rd (i-(readReg rn state)) state\n        | _ -> state\n    \n    let rsbR c s rd rn rm rsinst nORrn rstype state = //if s: sets N, Z, C, V flags\n        let op2 =\n            match rstype with\n            |T_I -> shiftI rsinst rm nORrn state \n            |T_R -> shiftR rsinst rm nORrn state \n        rsbI c s rd rn op2 state\n\n    //write op2-rn-!carry to rd\n    let rscI c s rd rn i state = //if s: sets N, Z, C, V flags\n        match (c state, s, readCFlag state) with \n        | (true, true, true) -> state\n                                |> setNZ (i-(readReg rn state)) \n                                |> setC (conv64 ~~~(readReg rn state)+1L) (conv64 i) \n                                |> setV (-(readReg rn state)) (i) \n                                |> writeReg rd (i-(readReg rn state)) \n        | (true, true, false) -> state\n                                |> setNZ (i-(readReg rn state)-1) \n                                |> setC (conv64 ~~~(readReg rn state)) (conv64 i) \n                                |> setV (-(readReg rn state)-1) (i) \n                                |> writeReg rd (i-(readReg rn state)-1) \n        | (true, false, true) -> writeReg rd (i-(readReg rn state)) state\n        | (true, false, false) -> writeReg rd (i-(readReg rn state)-1) state\n        | _ -> state\n    \n    let rscR c s rd rn rm rsinst nORrn rstype state = //if s: sets N, Z, C, V flags\n        let op2 =\n            match rstype with\n            |T_I -> shiftI rsinst rm nORrn state \n            |T_R -> shiftR rsinst rm nORrn state \n        rscI c s rd rn op2 state\n\n//CMP and CMN (DONE)\n//http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0068b/CIHIDDID.html\n\n    //same as SUBS but discards results\n    let cmpI c rn i state = //sets N, Z, C, V flags\n        match c state with \n        | true -> setNZ ((readReg rn state)-i) state\n                  |> setC (conv64 (readReg rn state)) ((conv64 ~~~i)+1L) \n                  |> setV (readReg rn state) (-i) \n        | false -> state\n\n    let cmpR c rn rm rsinst nORrn rstype state = //sets N, Z, C, V flags\n        let op2 =\n            match rstype with\n            |T_I -> shiftI rsinst rm nORrn state \n            |T_R -> shiftR rsinst rm nORrn state \n        cmpI c rn op2 state\n        \n    //same as ADDS but discards results\n    let cmnI c rn i state = //sets N, Z, C, V flags\n        match c state with \n        | true -> setNZ ((readReg rn state)+i) state\n                  |> setC (conv64 (readReg rn state)) (conv64 i)\n                  |> setV (readReg rn state) (i)\n        | false -> state\n\n    let cmnR c rn rm rsinst nORrn rstype state = //sets N, Z, C, V flags\n        let op2 =\n            match rstype with\n            |T_I -> shiftI rsinst rm nORrn state \n            |T_R -> shiftR rsinst rm nORrn state \n        cmnI c rn op2 state        \n\n//MUL and MLA (DONE)\n//http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0068b/CIHIHGGJ.html\n    \n    //write rm*rs to rd\n    let mulR c s rd rm rs state = //if s: sets N and Z flags only\n        let res = (readReg rm state)*(readReg rs state)\n        match (c state, s) with \n        | (true, true) -> state\n                          |> setNZ res \n                          |> writeReg rd res \n        | (true, false) -> writeReg rd res state\n        | _ -> state    \n    \n    //write rm*rs+rn to rd\n    let mlaR c s rd rm rs rn state = //if s: sets N and Z flags only\n        let res = (readReg rm state)*(readReg rs state)+(readReg rn state)\n        match (c state, s) with \n        | (true, true) -> state\n                          |> setNZ res \n                          |> writeReg rd res \n        | (true, false) -> writeReg rd res state\n        | _ -> state        \n\n//AND, ORR, EOR, and BIC (DONE)\n//http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0068b/CIHDAFAI.html\n\n    //write bitwise AND of rn and op2 to rd\n    let andI c s rd rn i state = //if s: sets N and Z flags only\n        match (c state, s) with \n        | (true, true) -> state\n                          |> setNZ ((readReg rn state)&&&i) \n                          |> writeReg rd ((readReg rn state)&&&i) \n        | (true, false) -> writeReg rd ((readReg rn state)&&&i) state\n        | _ -> state\n    \n    let andR c s rd rn rm rsinst nORrn rstype state = //if s: sets N, Z (and C) flags only\n        let op2 =\n            match rstype with\n            |T_I -> shiftI rsinst rm nORrn state \n            |T_R -> shiftR rsinst rm nORrn state \n        if c state\n        then match rstype with\n             |T_I -> shiftSetCI s rsinst rm nORrn state |> andI c s rd rn op2 \n             |T_R -> shiftSetCR s rsinst rm nORrn state |> andI c s rd rn op2 \n        else state\n\n    //write bitwise OR of rn and op2 to rd\n    let orrI c s rd rn i state = //if s: sets N and Z flags only\n        match (c state, s) with \n        | (true, true) -> state\n                          |> setNZ ((readReg rn state)|||i) \n                          |> writeReg rd ((readReg rn state)|||i) \n        | (true, false) -> writeReg rd ((readReg rn state)|||i) state\n        | _ -> state\n\n    let orrR c s rd rn rm rsinst nORrn rstype state = //if s: sets N, Z (and C) flags only\n        let op2 =\n            match rstype with\n            |T_I -> shiftI rsinst rm nORrn state \n            |T_R -> shiftR rsinst rm nORrn state \n        if c state\n        then match rstype with\n             |T_I -> shiftSetCI s rsinst rm nORrn state |> orrI c s rd rn op2 \n             |T_R -> shiftSetCR s rsinst rm nORrn state |> orrI c s rd rn op2 \n        else state\n\n    //write bitwise XOR of rn and op2 to rd\n    let eorI c s rd rn i state = //if s: sets N and Z flags only\n        match (c state, s) with \n        | (true, true) -> state\n                          |> setNZ ((readReg rn state)^^^i)\n                          |> writeReg rd ((readReg rn state)^^^i) \n        | (true, false) -> writeReg rd ((readReg rn state)^^^i) state\n        | _ -> state\n    \n    let eorR c s rd rn rm rsinst nORrn rstype state = //if s: sets N, Z (and C) flags only\n        let op2 =\n            match rstype with\n            |T_I -> shiftI rsinst rm nORrn state \n            |T_R -> shiftR rsinst rm nORrn state \n        if c state\n        then match rstype with\n             |T_I -> shiftSetCI s rsinst rm nORrn state |> eorI c s rd rn op2 \n             |T_R -> shiftSetCR s rsinst rm nORrn state |> eorI c s rd rn op2 \n        else state\n\n    //write bitwise AND of rn and NOT(op2) to rd\n    let bicI c s rd rn i state = //if s: sets N and Z flags only\n        andI c s rd rn (~~~i) state\n    \n    let bicR c s rd rn rm rsinst nORrn rstype state = //if s: sets N, Z (and C) flags only\n        let op2 =\n            match rstype with\n            |T_I -> shiftI rsinst rm nORrn state \n            |T_R -> shiftR rsinst rm nORrn state \n        if c state\n        then match rstype with\n             |T_I -> shiftSetCI s rsinst rm nORrn state |> bicI c s rd rn op2 \n             |T_R -> shiftSetCR s rsinst rm nORrn state |> bicI c s rd rn op2 \n        else state\n\n//TST and TEQ (DONE)\n//http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0068b/CIHCDEHH.html\n\n    //same as ANDS but discards results\n    let tstI c rn i state = //sets N and Z flags only\n        match c state with \n        | true -> setNZ ((readReg rn state)&&&i) state\n        | false -> state\n\n    let tstR c rn rm rsinst nORrn rstype state = //sets N, Z (and C) flags only\n        let op2 =\n            match rstype with\n            |T_I -> shiftI rsinst rm nORrn state \n            |T_R -> shiftR rsinst rm nORrn state \n        if c state\n        then match rstype with\n             |T_I -> shiftSetCI (true) rsinst rm nORrn state |> tstI c rn op2 \n             |T_R -> shiftSetCR (true) rsinst rm nORrn state |> tstI c rn op2 \n        else state\n        \n    //same as EORS but discards results\n    let teqI c rn i state = //sets N and Z flags only\n        match c state with \n        | true -> setNZ ((readReg rn state)^^^i) state\n        | false -> state\n\n    let teqR c rn rm rsinst nORrn rstype state = //sets N, Z (and C) flags only\n        let op2 =\n            match rstype with\n            |T_I -> shiftI rsinst rm nORrn state \n            |T_R -> shiftR rsinst rm nORrn state \n        if c state\n        then match rstype with\n             |T_I -> shiftSetCI (true) rsinst rm nORrn state |> teqI c rn op2 \n             |T_R -> shiftSetCR (true) rsinst rm nORrn state |> teqI c rn op2 \n        else state\n\n//CLZ (DONE)\n//http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0068b/CIHJGJED.html\n\n    //counts the number of leading zeroes in the value in Rm and returns the result in Rd\n    let clzR c rd rm state = \n        let rec loop m c = match m with\n                           | 0  -> 32\n                           | m when m < 0 -> c\n                           | _  -> loop (m <<< 1) (c + 1)\n        if c state\n        then writeReg rd (loop (readReg rm state) 0) state\n        else state\n        \n//LSL, LSR, ASR, ROR, RRX (DONE)\n\n    //logical shift left rm by rn, write into rd\n    let lslR c s rd rm rn state = //if s: set N and Z only\n        let op2 = shiftR (T_LSL) rm rn state\n        match (c state, s) with\n        | (true, true) -> state\n                          |> setNZ op2\n                          |> shiftSetCR s (T_LSL) rm rn \n                          |> writeReg rd op2 \n        | (true, false) -> writeReg rd op2 state\n        | _ -> state        \n\n    //logical shift right rm by rn, write into rd\n    let lsrR c s rd rm rn state = //if s: set N and Z only\n        let op2 = shiftR (T_LSR) rm rn state\n        match (c state, s) with\n        | (true, true) -> state\n                          |> setNZ op2\n                          |> shiftSetCR s (T_LSR) rm rn \n                          |> writeReg rd op2 \n        | (true, false) -> writeReg rd op2 state\n        | _ -> state       \n        \n     //arithmetic shift right rm by rn, write into rd\n    let asrR c s rd rm rn state = //if s: set N and Z only\n        let op2 = shiftR (T_ASR) rm rn state\n        match (c state, s) with\n        | (true, true) -> state\n                         |> setNZ op2\n                         |> shiftSetCR s (T_ASR) rm rn \n                         |> writeReg rd op2 \n        | (true, false) -> writeReg rd op2 state\n        | _ -> state        \n     \n     //rotate right rm by rn, write into rd\n    let rorR c s rd rm rn state = //if s: set N, Z and (C) only\n        let op2 = shiftR (T_ROR) rm rn state\n        match (c state, s) with\n        | (true, true) -> state\n                          |> setNZ op2 \n                          |> shiftSetCR s (T_ROR) rm rn \n                          |> writeReg rd op2 \n        | (true, false) -> writeReg rd op2 state\n        | _ -> state             \n        \n     //rotate right (and extend) rm by 1, write into rd\n    let rrxR c s rd rm state = //if s: set N, Z (and C) only\n        let op2 = shiftR (T_RRX) rm (1) state\n        match (c state, s) with\n        | (true, true) -> state\n                          |> setNZ op2 \n                          |> shiftSetCR s (T_RRX) rm (1) \n                          |> writeReg rd op2 \n        | (true, false) -> writeReg rd op2 state\n        | _ -> state              \n\n//B, BL, BX, BLX (DONE)\n//http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0068b/CIHFDDAF.html\n//http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0068b/CIHDGEAI.html\n//http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0068b/CIHFJFDG.html\n\n    //branch to address corresponding to label\n    let b c label state =\n        if c state\n        then writePC label state\n        else state\n\n    //store address of next instruction in r14, branch to address corresponding to label\n    let bl c label state =\n        if c state\n        then writeReg 14 (readPC state) state\n             |> writePC label \n        else state\n\n    //branch to address stored in rm\n    let bx c rm state =\n        if c state\n        then writePC ((readReg rm state)-4) state \n        else state\n\n    //store address of next instruction in r14, branch to address indicated by op2\n    let blxR c rm state = \n        if c state\n        then writeReg 14 (readPC state) state\n             |> writePC ((readReg rm state)-4) \n        else state\n\n    let blxL label state = //only if no condition follows\n        writeReg 14 (readPC state) state\n        |> writePC label \n\n//ADR, LDR and STR (DONE)\n//http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0041c/Babcjaii.html\n//http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0068b/Bcfihdhj.html\n\n    //writes the address corresponding to label into rd\n    let adr c rd label state =\n        if c state\n        then writeReg rd label state  \n        else state\n        \n    //Loads word from label to rd.\n    let ldrWL c rd label state = \n        if c state\n        then writeReg rd (readMem label state) state  \n        else state\n    \n    //Loads least significant byte from label to rd.\n    let ldrBL c rd label state = \n        if c state\n        then writeReg rd (int(readMemByte label state)) state  \n        else state\n        \n    //More LDRs (details see ARMv4.md)\n    let ldrWbI c inc rd rn i state = \n        if c state\n        then match inc with \n             | true -> state\n                       |> writeReg rd (readMem ((readReg rn state)+i) state)  \n                       |> writeReg rn ((readReg rn state)+i)\n             | false -> state\n                        |> writeReg rd (readMem ((readReg rn state)+i) state) \n        else state\n    \n    let ldrWbR c inc rd rn rm rsinst nORrn rstype state = \n        let op2 =\n            match rstype with\n            |T_I -> shiftI rsinst rm nORrn state \n            |T_R -> shiftR rsinst rm nORrn state \n        if c state\n        then ldrWbI c inc rd rn op2 state\n        else state\n    \n    let ldrWaI c rd rn i state = \n        if c state\n        then state\n             |> writeReg rd (readMem (readReg rn state) state)  \n             |> writeReg rn ((readReg rn state)+i)\n        else state\n    \n    let ldrWaR c rd rn rm rsinst nORrn rstype state = \n        let op2 =\n            match rstype with\n            |T_I -> shiftI rsinst rm nORrn state \n            |T_R -> shiftR rsinst rm nORrn state \n        if c state\n        then ldrWaI c rd rn op2 state\n        else state\n    \n    let ldrBbI c inc rd rn i state = \n        if c state\n        then match inc with \n             | true -> state\n                       |> writeReg rd (int(readMemByte ((readReg rn state)+i) state))  \n                       |> writeReg rn ((readReg rn state)+i)\n             | false -> state\n                        |> writeReg rd (int(readMemByte ((readReg rn state)+i) state))\n        else state\n    \n    let ldrBbR c inc rd rn rm rsinst nORrn rstype state = \n        let op2 =\n            match rstype with\n            |T_I -> shiftI rsinst rm nORrn state \n            |T_R -> shiftR rsinst rm nORrn state \n        if c state\n        then ldrBbI c inc rd rn op2 state\n        else state\n    \n    let ldrBaI c rd rn i state = \n        if c state\n        then state\n             |> writeReg rd (int(readMemByte (readReg rn state) state))  \n             |> writeReg rn ((readReg rn state)+i)\n        else state\n    \n    let ldrBaR c rd rn rm rsinst nORrn rstype state = \n        let op2 =\n            match rstype with\n            |T_I -> shiftI rsinst rm nORrn state \n            |T_R -> shiftR rsinst rm nORrn state \n        if c state\n        then ldrBaI c rd rn op2 state\n        else state\n    \n    //STRs (details see ARMv4.md)\n    let strWbI c inc rd rn i state = \n        if c state\n        then match inc with \n             | true -> state\n                       |> writeMem ((readReg rn state)+i) (readReg rd state) \n                       |> writeReg rn ((readReg rn state)+i) \n             | false -> state\n                        |> writeMem ((readReg rn state)+i) (readReg rd state) \n        else state\n    \n    let strWbR c inc rd rn rm rsinst nORrn rstype state = \n        let op2 =\n            match rstype with\n            |T_I -> shiftI rsinst rm nORrn state \n            |T_R -> shiftR rsinst rm nORrn state \n        if c state\n        then strWbI c inc rd rn op2 state\n        else state\n    \n    let strWaI c rd rn i state = \n        if c state\n        then state\n             |> writeMem (readReg rn state) (readReg rd state) \n             |> writeReg rn ((readReg rn state)+i) \n        else state\n    \n    let strWaR c rd rn rm rsinst nORrn rstype state = \n        let op2 =\n            match rstype with\n            |T_I -> shiftI rsinst rm nORrn state \n            |T_R -> shiftR rsinst rm nORrn state \n        if c state\n        then strWaI c rd rn op2 state\n        else state\n    \n    let strBbI c inc rd rn i state = \n        let writeVal = byte(readReg rd state) \n        if c state\n        then match inc with \n             | true -> state\n                       |> writeMemByte ((readReg rn state)+i) writeVal\n                       |> writeReg rn ((readReg rn state)+i)\n             | false -> state\n                        |> writeMemByte ((readReg rn state)+i) writeVal\n        else state\n    \n    let strBbR c inc rd rn rm rsinst nORrn rstype state = \n        let op2 =\n            match rstype with\n            |T_I -> shiftI rsinst rm nORrn state \n            |T_R -> shiftR rsinst rm nORrn state \n        if c state\n        then strBbI c inc rd rn op2 state\n        else state\n    \n    let strBaI c rd rn i state = \n        let writeVal = byte(readReg rd state)\n        if c state\n        then state\n             |> writeMemByte (readReg rn state) writeVal\n             |> writeReg rn ((readReg rn state)+i)\n        else state\n    \n    let strBaR c rd rn rm rsinst nORrn rstype state = \n        let op2 =\n            match rstype with\n            |T_I -> shiftI rsinst rm nORrn state \n            |T_R -> shiftR rsinst rm nORrn state \n        if c state\n        then strBaI c rd rn op2 state\n        else state\n\n//LDM and STM\n//http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0068b/CIHCADDA.html\n//see http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0473c/Cacbgchh.html for equivalent modes\n    \n    let rec ldmIA c write rn reglist state = \n        let rec loop mem reglist state = \n            match reglist with\n            | hReg :: tailReg -> state\n                                 |> writeReg hReg (readMem mem state) \n                                 |> loop (mem+4) tailReg\n            | [] -> state\n        let startMem = readReg rn state\n        if c state\n        then if write then (writeReg rn (startMem+(List.length reglist)*4) state) else state \n             |> loop startMem reglist\n        else state\n    \n    let ldmIB c write rn reglist state = \n        let rec loop mem reglist state = \n            match reglist with\n            | hReg :: tailReg -> state\n                                 |> writeReg hReg (readMem mem state) \n                                 |> loop (mem+4) tailReg\n            | [] -> state\n        let startMem = readReg rn state\n        if c state\n        then if write then (writeReg rn (startMem+(List.length reglist)*4) state) else state\n             |> loop (startMem+4) reglist\n        else state\n    \n    let ldmDA c write rn reglist state = \n        let rec loop mem reglist state = \n            match reglist with\n            | hReg :: tailReg -> state\n                                 |> writeReg hReg (readMem mem state) \n                                 |> loop (mem-4) tailReg\n            | [] -> state\n        let startMem = readReg rn state\n        if c state\n        then if write then (writeReg rn (startMem-(List.length reglist)*4) state) else state\n             |> loop startMem reglist\n        else state\n    \n    let ldmDB c write rn reglist state = \n        let rec loop mem reglist state = \n            match reglist with\n            | hReg :: tailReg -> state\n                                 |> writeReg hReg (readMem mem state) \n                                 |> loop (mem-4) tailReg\n            | [] -> state\n        let startMem = readReg rn state\n        if c state\n        then if write then (writeReg rn (startMem-(List.length reglist)*4) state) else state\n             |> loop (startMem-4) reglist\n        else state\n    \n    let stmIA c write rn reglist state = \n        let rec loop mem reglist state = \n            match reglist with\n            | hReg :: tailReg -> state\n                                 |> writeMem mem (readReg hReg state) \n                                 |> loop (mem+4) tailReg\n            | [] -> state\n        let startMem = readReg rn state\n        if c state\n        then if write then (writeReg rn (startMem+(List.length reglist)*4) state) else state\n             |> loop startMem reglist\n        else state\n        \n    let stmIB c write rn reglist state = \n        let rec loop mem reglist state = \n            match reglist with\n            | hReg :: tailReg -> state\n                                 |> writeMem mem (readReg hReg state) \n                                 |> loop (mem+4) tailReg\n            | [] -> state\n        let startMem = readReg rn state\n        if c state\n        then if write then (writeReg rn (startMem+(List.length reglist)*4) state) else state\n             |> loop (startMem+4) reglist\n        else state\n    \n    let stmDA c write rn reglist state = \n        let rec loop mem reglist state = \n            match reglist with\n            | hReg :: tailReg -> state\n                                 |> writeMem mem (readReg hReg state) \n                                 |> loop (mem-4) tailReg\n            | [] -> state\n        let startMem = readReg rn state\n        if c state\n        then if write then (writeReg rn (startMem-(List.length reglist)*4) state) else state\n             |> loop startMem reglist\n        else state\n    \n    let stmDB c write rn reglist state = \n        let rec loop mem reglist state = \n            match reglist with\n            | hReg :: tailReg -> state\n                                 |> writeMem mem (readReg hReg state) \n                                 |> loop (mem-4) tailReg\n            | [] -> state\n        let startMem = readReg rn state\n        if c state\n        then if write then (writeReg rn (startMem-(List.length reglist)*4) state) else state\n             |> loop (startMem-4) reglist\n        else state\n    \n//DCD, EQU and FILL (DONE)\n//http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0041c/Babbfcga.html\n//http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0489h/Caccddic.html\n//http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0489f/Babchded.html\n\n    let dcd label valList state = \n        let rec loop mem vlist state = \n            match vlist with\n            | (i,'i') :: tailList -> state\n                                    |> writeMem mem i\n                                    |> loop (mem+4) tailList\n\n            | (r,'r') :: tailList -> state\n                                    |> writeMem mem (readReg r state)\n                                    |> loop (mem+4) tailList\n            | (m,'m') :: tailList -> state\n                                    |> writeMem mem (readMem m state)\n                                    |> loop (mem+4) tailList\n            | [] -> state\n            | _ -> failwith \"Invalid data type.\"\n        loop label valList state\n    \n    let equ name value state = \n        match value with\n        | (i,'i') -> writeMem name i state\n        | (r,'r') -> writeMem name (readReg r state) state\n        | (m,'m') -> writeMem name (readMem m state) state\n        | _ -> failwith \"Invalid data type.\"\n\n    let fillW label data value state = \n        let rec loop mem n val2 state = \n            if n=0 then state else (state |> writeMem mem val2 |> loop (mem+4) (n-4) val2)\n        loop label data value state\n    \n//END (DONE)\n    //stop emulation\n    let endI c finalInstAddr state = \n        if c state\n        then writePC finalInstAddr state \n        else state\n","﻿// This module contains the parser:\n\nnamespace Parse\nmodule Parser =\n    \n    open Tokeniser\n    open ParseError\n    open Interpret.ARMv4\n    open Common.Error\n    open Common.Types\n\n    /// Replaces placeholder branch and end references with correct instructions.\n    let private resolveRefs labels endMem instrLst =\n        let rec resolveRec labels endMem outLst = function\n            | (m, LabelRef(f))::t -> match f labels with\n                                       | Ok(h) -> resolveRec labels endMem (outLst@[(m, h)]) t\n                                       | Err(l,s) -> Err(l,s)\n            | (m, EndRef(f))::t -> resolveRec labels endMem (outLst@[(m, f endMem)]) t\n            | h::t -> resolveRec labels endMem (outLst@[h]) t\n            | [] -> Ok(outLst)\n        resolveRec labels endMem [] instrLst\n\n    /// Check number is 12-bit immediate value (8bit shifted by 5 bits)\n    let private int12 num =\n        //let checkBottom2 n = (n &&& 3u <> 0u)\n        let rec shift n shamt =\n            match (n &&& (0xFFFFFF00u)) = 0u with\n            | true -> true\n            | false when (shamt < 15) -> shift ((n>>>2)|||(n<<<30)) (shamt+1)\n            | _ -> false\n        shift (uint32 num) 0\n\n    /// Check number is valid load/store offset.\n    let private offset num =\n        (num>=(-4095))&&(num<=4095)\n\n    /// Check number range is valid for rotate.\n    let private shint n shiftType =\n        match shiftType with\n        | T_LSL -> (n>=0)&&(n<=31)\n        | T_LSR -> (n>=1)&&(n<=32)\n        | T_ASR -> (n>=1)&&(n<=32)\n        | T_ROR -> (n>=1)&&(n<=31)\n        | T_RRX -> true\n\n    /// Make a list of registers for LDM/STM, from token list.\n    let private regList tokLst =\n        /// Gets register range {Rx-Ry}\n        let rec regRange r1 r2 outLst =\n            match r1 < r2 with\n            | true -> regRange (r1+1) r2 (outLst@[r1])\n            | false when r1=r2 -> Ok(outLst@[r1])\n            | false -> invalidRegRange 0\n\n        /// Gets register list from {}, for LDM/STM\n        let rec regRec outLst = function\n            | T_REG r :: T_COMMA :: t -> regRec (outLst@[r]) t\n            | T_REG r1 :: T_DASH :: T_REG r2 :: T_COMMA :: t ->\n                match regRange r1 r2 [] with\n                | Ok(lst) -> regRec (outLst@lst) t\n                | Err(_,s) -> Err(0,s)\n            | T_REG r :: T_R_CBR :: t -> Ok(outLst@[r], t)\n            | T_REG r1 :: T_DASH :: T_REG r2 :: T_R_CBR :: t ->\n                match regRange r1 r2 [] with\n                | Ok(lst) -> Ok(outLst@lst, t)\n                | Err(_,s) -> Err(0,s)\n            | T_ERROR s :: t -> invalidToken 0 s\n            | tok :: t -> unexpectedToken 0 tok t\n            | [] -> invalidRegRange 0\n        regRec [] tokLst\n\n    /// Matches the shift immediate.\n    let private shiftMatch z tokLst =\n        match (z,tokLst) with\n        | (T_RRX, t) -> Ok(T_I,0,t)\n        | (_, T_INT i :: t) -> match shint i z with\n                               | true -> Ok(T_I,i,t)\n                               | false -> invalidShiftImmRange 0 i z\n        | (_, T_REG rs :: t) -> Ok(T_R,rs,t)\n        | (_, tok :: t) -> unexpectedToken 0 tok t\n        | (_, []) -> invalidShiftMatch 0\n\n\n    /// Parses a list of tokens into a memory map of instructions.\n    let parser tokLst =\n        /// Function that resolves branch.\n        let branchRef l c s bInst (labels:Map<string,int>) =\n            match Map.tryFind s labels with\n            | Some(memLoc) -> Ok(Instr(l, bInst c (memLoc-4)))\n            | None -> undefinedLabel l s\n\n        /// Function that resolves ldr =label.\n        let lsaRef l c rd s inst (labels:Map<string,int>) =\n            match Map.tryFind s labels with\n            | Some(memLoc) -> Ok(Instr(l, inst c rd memLoc))\n            | None -> undefinedLabel l s\n\n        /// Function that resolves end.\n        let endRef l c endMem =\n            Instr(l, endI c (endMem-4))\n\n        /// Construct a list of instructions. m: memory location, l: line number.\n        let rec parseRec m l labels outLst = function\n            // ARITHMETIC\n\n            | T_MOV (c,s) :: T_REG rd :: T_COMMA :: T_INT i :: t ->\n                match int12 i with\n                | true -> parseRec (m+4) l labels (outLst@[(m, Instr(l, movI c s rd i))]) t\n                | false -> invalidImmRange l i\n            | T_MOV (c,s) :: T_REG rd :: T_COMMA :: T_REG rm :: T_COMMA :: T_SHIFT (z,_) :: t ->\n                match shiftMatch z t with\n                | Ok(ir,v,tail) -> parseRec (m+4) l labels (outLst@[(m, Instr(l, movR c s rd rm z v ir))]) tail\n                | Err(_,s) -> Err(l,s)\n            | T_MOV (c,s) :: T_REG rd :: T_COMMA :: T_REG rm :: t ->\n                parseRec (m+4) l labels (outLst@[(m, Instr(l, movR c s rd rm T_LSL 0 T_I))]) t\n\n            | T_MVN (c,s) :: T_REG rd :: T_COMMA :: T_INT i :: t ->\n                match int12 i with\n                | true -> parseRec (m+4) l labels (outLst@[(m, Instr(l, mvnI c s rd i))]) t\n                | false -> invalidImmRange l i\n            | T_MVN (c,s) :: T_REG rd :: T_COMMA :: T_REG rm :: T_COMMA :: T_SHIFT (z,_) :: t ->\n                match shiftMatch z t with\n                | Ok(ir,v,tail) -> parseRec (m+4) l labels (outLst@[(m, Instr(l, mvnR c s rd rm z v ir))]) tail\n                | Err(_,s) -> Err(l,s)\n            | T_MVN (c,s) :: T_REG rd :: T_COMMA :: T_REG rm :: t ->\n                parseRec (m+4) l labels (outLst@[(m, Instr(l, mvnR c s rd rm T_LSL 0 T_I))]) t\n\n            | T_ADD (c,s) :: T_REG rd :: T_COMMA :: T_REG rn :: T_COMMA :: T_INT i :: t ->\n                match int12 i with\n                | true -> parseRec (m+4) l labels (outLst@[(m, Instr(l, addI c s rd rn i))]) t\n                | false -> invalidImmRange l i\n            | T_ADD (c,s) :: T_REG rd :: T_COMMA :: T_REG rn :: T_COMMA :: T_REG rm :: T_COMMA :: T_SHIFT (z,_) :: t ->\n                match shiftMatch z t with\n                | Ok(ir,v,tail) -> parseRec (m+4) l labels (outLst@[(m, Instr(l, addR c s rd rn rm z v ir))]) tail\n                | Err(_,s) -> Err(l,s)\n            | T_ADD (c,s) :: T_REG rd :: T_COMMA :: T_REG rn :: T_COMMA :: T_REG rm :: t ->\n                parseRec (m+4) l labels (outLst@[(m, Instr(l, addR c s rd rn rm T_LSL 0 T_I))]) t\n\n            | T_ADC (c,s) :: T_REG rd :: T_COMMA :: T_REG rn :: T_COMMA :: T_INT i :: t ->\n                match int12 i with\n                | true -> parseRec (m+4) l labels (outLst@[(m, Instr(l, adcI c s rd rn i))]) t\n                | false -> invalidImmRange l i\n            | T_ADC (c,s) :: T_REG rd :: T_COMMA :: T_REG rn :: T_COMMA :: T_REG rm :: T_COMMA :: T_SHIFT (z,_) :: t ->\n                match shiftMatch z t with\n                | Ok(ir,v,tail) -> parseRec (m+4) l labels (outLst@[(m, Instr(l, adcR c s rd rn rm z v ir))]) tail\n                | Err(_,s) -> Err(l,s)\n            | T_ADC (c,s) :: T_REG rd :: T_COMMA :: T_REG rn :: T_COMMA :: T_REG rm :: t ->\n                parseRec (m+4) l labels (outLst@[(m, Instr(l, adcR c s rd rn rm T_LSL 0 T_I))]) t\n\n            | T_SUB (c,s) :: T_REG rd :: T_COMMA :: T_REG rn :: T_COMMA :: T_INT i :: t ->\n                match int12 i with\n                | true -> parseRec (m+4) l labels (outLst@[(m, Instr(l, subI c s rd rn i))]) t\n                | false -> invalidImmRange l i\n            | T_SUB (c,s) :: T_REG rd :: T_COMMA :: T_REG rn :: T_COMMA :: T_REG rm :: T_COMMA :: T_SHIFT (z,_) :: t ->\n                match shiftMatch z t with\n                | Ok(ir,v,tail) -> parseRec (m+4) l labels (outLst@[(m, Instr(l, subR c s rd rn rm z v ir))]) tail\n                | Err(_,s) -> Err(l,s)\n            | T_SUB (c,s) :: T_REG rd :: T_COMMA :: T_REG rn :: T_COMMA :: T_REG rm :: t ->\n                parseRec (m+4) l labels (outLst@[(m, Instr(l, subR c s rd rn rm T_LSL 0 T_I))]) t\n\n            | T_SBC (c,s) :: T_REG rd :: T_COMMA :: T_REG rn :: T_COMMA :: T_INT i :: t ->\n                match int12 i with\n                | true -> parseRec (m+4) l labels (outLst@[(m, Instr(l, sbcI c s rd rn i))]) t\n                | false -> invalidImmRange l i\n            | T_SBC (c,s) :: T_REG rd :: T_COMMA :: T_REG rn :: T_COMMA :: T_REG rm :: T_COMMA :: T_SHIFT (z,_) :: t ->\n                match shiftMatch z t with\n                | Ok(ir,v,tail) -> parseRec (m+4) l labels (outLst@[(m, Instr(l, sbcR c s rd rn rm z v ir))]) tail\n                | Err(_,s) -> Err(l,s)\n            | T_SBC (c,s) :: T_REG rd :: T_COMMA :: T_REG rn :: T_COMMA :: T_REG rm :: t ->\n                parseRec (m+4) l labels (outLst@[(m, Instr(l, sbcR c s rd rn rm T_LSL 0 T_I))]) t\n\n            | T_RSB (c,s) :: T_REG rd :: T_COMMA :: T_REG rn :: T_COMMA :: T_INT i :: t ->\n                match int12 i with\n                | true -> parseRec (m+4) l labels (outLst@[(m, Instr(l, rsbI c s rd rn i))]) t\n                | false -> invalidImmRange l i\n            | T_RSB (c,s) :: T_REG rd :: T_COMMA :: T_REG rn :: T_COMMA :: T_REG rm :: T_COMMA :: T_SHIFT (z,_) :: t ->\n                match shiftMatch z t with\n                | Ok(ir,v,tail) -> parseRec (m+4) l labels (outLst@[(m, Instr(l, rsbR c s rd rn rm z v ir))]) tail\n                | Err(_,s) -> Err(l,s)\n            | T_RSB (c,s) :: T_REG rd :: T_COMMA :: T_REG rn :: T_COMMA :: T_REG rm :: t ->\n                parseRec (m+4) l labels (outLst@[(m, Instr(l, rsbR c s rd rn rm T_LSL 0 T_I))]) t\n\n            | T_RSC (c,s) :: T_REG rd :: T_COMMA :: T_REG rn :: T_COMMA :: T_INT i :: t ->\n                match int12 i with\n                | true -> parseRec (m+4) l labels (outLst@[(m, Instr(l, rscI c s rd rn i))]) t\n                | false -> invalidImmRange l i\n            | T_RSC (c,s) :: T_REG rd :: T_COMMA :: T_REG rn :: T_COMMA :: T_REG rm :: T_COMMA :: T_SHIFT (z,_) :: t ->\n                match shiftMatch z t with\n                | Ok(ir,v,tail) -> parseRec (m+4) l labels (outLst@[(m, Instr(l, rscR c s rd rn rm z v ir))]) tail\n                | Err(_,s) -> Err(l,s)\n            | T_RSC (c,s) :: T_REG rd :: T_COMMA :: T_REG rn :: T_COMMA :: T_REG rm :: t ->\n                parseRec (m+4) l labels (outLst@[(m, Instr(l, rscR c s rd rn rm T_LSL 0 T_I))]) t\n\n            | T_MUL (c,s) :: T_REG rd :: T_COMMA :: T_REG rm :: T_COMMA :: T_REG rs :: t ->\n                parseRec (m+4) l labels (outLst@[(m, Instr(l, mulR c s rd rm rs))]) t\n\n            | T_MLA (c,s) :: T_REG rd :: T_COMMA :: T_REG rm :: T_COMMA :: T_REG rs :: T_COMMA :: T_REG rn :: t ->\n                parseRec (m+4) l labels (outLst@[(m, Instr(l, mlaR c s rd rm rs rn))]) t\n\n            // LOGIC\n            | T_AND (c,s) :: T_REG rd :: T_COMMA :: T_REG rn :: T_COMMA :: T_INT i :: t ->\n                match int12 i with\n                | true -> parseRec (m+4) l labels (outLst@[(m, Instr(l, andI c s rd rn i))]) t\n                | false -> invalidImmRange l i\n            | T_AND (c,s) :: T_REG rd :: T_COMMA :: T_REG rn :: T_COMMA :: T_REG rm :: T_COMMA :: T_SHIFT (z,_) :: t ->\n                match shiftMatch z t with\n                | Ok(ir,v,tail) -> parseRec (m+4) l labels (outLst@[(m, Instr(l, andR c s rd rn rm z v ir))]) tail\n                | Err(_,s) -> Err(l,s)\n            | T_AND (c,s) :: T_REG rd :: T_COMMA :: T_REG rn :: T_COMMA :: T_REG rm :: t ->\n                parseRec (m+4) l labels (outLst@[(m, Instr(l, andR c s rd rn rm T_LSL 0 T_I))]) t\n\n            | T_ORR (c,s) :: T_REG rd :: T_COMMA :: T_REG rn :: T_COMMA :: T_INT i :: t ->\n                match int12 i with\n                | true -> parseRec (m+4) l labels (outLst@[(m, Instr(l, orrI c s rd rn i))]) t\n                | false -> invalidImmRange l i\n            | T_ORR (c,s) :: T_REG rd :: T_COMMA :: T_REG rn :: T_COMMA :: T_REG rm :: T_COMMA :: T_SHIFT (z,_) :: t ->\n                match shiftMatch z t with\n                | Ok(ir,v,tail) -> parseRec (m+4) l labels (outLst@[(m, Instr(l, orrR c s rd rn rm z v ir))]) tail\n                | Err(_,s) -> Err(l,s)\n            | T_ORR (c,s) :: T_REG rd :: T_COMMA :: T_REG rn :: T_COMMA :: T_REG rm :: t ->\n                parseRec (m+4) l labels (outLst@[(m, Instr(l, orrR c s rd rn rm T_LSL 0 T_I))]) t\n\n            | T_EOR (c,s) :: T_REG rd :: T_COMMA :: T_REG rn :: T_COMMA :: T_INT i :: t ->\n                match int12 i with\n                | true -> parseRec (m+4) l labels (outLst@[(m, Instr(l, eorI c s rd rn i))]) t\n                | false -> invalidImmRange l i\n            | T_EOR (c,s) :: T_REG rd :: T_COMMA :: T_REG rn :: T_COMMA :: T_REG rm :: T_COMMA :: T_SHIFT (z,_) :: t ->\n                match shiftMatch z t with\n                | Ok(ir,v,tail) -> parseRec (m+4) l labels (outLst@[(m, Instr(l, eorR c s rd rn rm z v ir))]) tail\n                | Err(_,s) -> Err(l,s)\n            | T_EOR (c,s) :: T_REG rd :: T_COMMA :: T_REG rn :: T_COMMA :: T_REG rm :: t ->\n                parseRec (m+4) l labels (outLst@[(m, Instr(l, eorR c s rd rn rm T_LSL 0 T_I))]) t\n\n            | T_BIC (c,s) :: T_REG rd :: T_COMMA :: T_REG rn :: T_COMMA :: T_INT i :: t ->\n                match int12 i with\n                | true -> parseRec (m+4) l labels (outLst@[(m, Instr(l, bicI c s rd rn i))]) t\n                | false -> invalidImmRange l i\n            | T_BIC (c,s) :: T_REG rd :: T_COMMA :: T_REG rn :: T_COMMA :: T_REG rm :: T_COMMA :: T_SHIFT (z,_) :: t ->\n                match shiftMatch z t with\n                | Ok(ir,v,tail) -> parseRec (m+4) l labels (outLst@[(m, Instr(l, bicR c s rd rn rm z v ir))]) tail\n                | Err(_,s) -> Err(l,s)\n            | T_BIC (c,s) :: T_REG rd :: T_COMMA :: T_REG rn :: T_COMMA :: T_REG rm :: t ->\n                parseRec (m+4) l labels (outLst@[(m, Instr(l, bicR c s rd rn rm T_LSL 0 T_I))]) t\n\n            // COMPARISON\n            | T_CMP c :: T_REG rn :: T_COMMA :: T_INT i :: t ->\n                match int12 i with\n                | true -> parseRec (m+4) l labels (outLst@[(m, Instr(l, cmpI c rn i))]) t\n                | false -> invalidImmRange l i\n            | T_CMP c :: T_REG rn :: T_COMMA :: T_REG rm :: T_COMMA :: T_SHIFT (z,_) :: t ->\n                match shiftMatch z t with\n                | Ok(ir,v,tail) -> parseRec (m+4) l labels (outLst@[(m, Instr(l, cmpR c rn rm z v ir))]) tail\n                | Err(_,s) -> Err(l,s)\n            | T_CMP c :: T_REG rn :: T_COMMA :: T_REG rm :: t ->\n                parseRec (m+4) l labels (outLst@[(m, Instr(l, cmpR c rn rm T_LSL 0 T_I))]) t\n\n            | T_CMN c :: T_REG rn :: T_COMMA :: T_INT i :: t ->\n                match int12 i with\n                | true -> parseRec (m+4) l labels (outLst@[(m, Instr(l, cmnI c rn i))]) t\n                | false -> invalidImmRange l i\n            | T_CMN c :: T_REG rn :: T_COMMA :: T_REG rm :: T_COMMA :: T_SHIFT (z,_) :: t ->\n                match shiftMatch z t with\n                | Ok(ir,v,tail) -> parseRec (m+4) l labels (outLst@[(m, Instr(l, cmnR c rn rm z v ir))]) tail\n                | Err(_,s) -> Err(l,s)\n            | T_CMN c :: T_REG rn :: T_COMMA :: T_REG rm :: t ->\n                parseRec (m+4) l labels (outLst@[(m, Instr(l, cmnR c rn rm T_LSL 0 T_I))]) t\n\n            | T_TST c :: T_REG rn :: T_COMMA :: T_INT i :: t ->\n                match int12 i with\n                | true -> parseRec (m+4) l labels (outLst@[(m, Instr(l, tstI c rn i))]) t\n                | false -> invalidImmRange l i\n            | T_TST c :: T_REG rn :: T_COMMA :: T_REG rm :: T_COMMA :: T_SHIFT (z,_) :: t ->\n                match shiftMatch z t with\n                | Ok(ir,v,tail) -> parseRec (m+4) l labels (outLst@[(m, Instr(l, tstR c rn rm z v ir))]) tail\n                | Err(_,s) -> Err(l,s)\n            | T_TST c :: T_REG rn :: T_COMMA :: T_REG rm :: t ->\n                parseRec (m+4) l labels (outLst@[(m, Instr(l, tstR c rn rm T_LSL 0 T_I))]) t\n\n            | T_TEQ c :: T_REG rn :: T_COMMA :: T_INT i :: t ->\n                match int12 i with\n                | true -> parseRec (m+4) l labels (outLst@[(m, Instr(l, teqI c rn i))]) t\n                | false -> invalidImmRange l i\n            | T_TEQ c :: T_REG rn :: T_COMMA :: T_REG rm :: T_COMMA :: T_SHIFT (z,_) :: t ->\n                match shiftMatch z t with\n                | Ok(ir,v,tail) -> parseRec (m+4) l labels (outLst@[(m, Instr(l, teqR c rn rm z v ir))]) tail\n                | Err(_,s) -> Err(l,s)\n            | T_TEQ c :: T_REG rn :: T_COMMA :: T_REG rm :: t ->\n                parseRec (m+4) l labels (outLst@[(m, Instr(l, teqR c rn rm T_LSL 0 T_I))]) t\n\n            // BITWISE\n            (*| T_CLZ c :: T_REG rn :: T_COMMA :: T_INT i :: t ->\n                // TODO tst->clz\n                parseRec (m+4) l labels (outLst@[(m, Instr(l, clzI c rn i))]) t\n            | T_CLZ c :: T_REG rn :: T_COMMA :: T_REG rm :: T_COMMA :: T_SHIFT (z,_) :: T_INT i :: t ->\n                parseRec (m+4) l labels (outLst@[(m, Instr(l, tstR c rn rm z i T_I))]) t\n            | T_CLZ c :: T_REG rn :: T_COMMA :: T_REG rm :: T_COMMA :: T_SHIFT (z,_) :: T_REG rs :: t ->\n                parseRec (m+4) l labels (outLst@[(m, Instr(l, tstR c rn rm z rs T_R))]) t\n            | T_CLZ c :: T_REG rn :: T_COMMA :: T_REG rm :: t ->\n                parseRec (m+4) l labels (outLst@[(m, Instr(l, tstR c rn rm T_LSL 0 T_I))]) t*)\n\n            | T_SHIFT (T_LSL,(c,s)) :: T_REG rd :: T_COMMA :: T_REG rm :: T_COMMA :: T_REG rn :: t ->\n                parseRec (m+4) l labels (outLst@[(m, Instr(l, lslR c s rd rm rn))]) t\n\n            | T_SHIFT (T_LSR,(c,s)) :: T_REG rd :: T_COMMA :: T_REG rm :: T_COMMA :: T_REG rn :: t ->\n                parseRec (m+4) l labels (outLst@[(m, Instr(l, lsrR c s rd rm rn))]) t\n\n            | T_SHIFT (T_ASR,(c,s)) :: T_REG rd :: T_COMMA :: T_REG rm :: T_COMMA :: T_REG rn :: t ->\n                parseRec (m+4) l labels (outLst@[(m, Instr(l, asrR c s rd rm rn))]) t\n\n            | T_SHIFT (T_ROR,(c,s)) :: T_REG rd :: T_COMMA :: T_REG rm :: T_COMMA :: T_REG rn :: t ->\n                parseRec (m+4) l labels (outLst@[(m, Instr(l, rorR c s rd rm rn))]) t\n\n            | T_SHIFT (T_RRX,(c,s)) :: T_REG rd :: T_COMMA :: T_REG rm :: t ->\n                parseRec (m+4) l labels (outLst@[(m, Instr(l, rrxR c s rd rm))]) t\n\n            // BRANCHING\n            | T_B c :: T_LABEL s :: t ->\n                parseRec (m+4) l labels (outLst@[(m, LabelRef(branchRef l c s b))]) t\n            | T_BL c :: T_LABEL s :: t ->\n                parseRec (m+4) l labels (outLst@[(m, LabelRef(branchRef l c s bl))]) t\n            | T_BX c :: T_REG r :: t ->\n                parseRec (m+4) l labels (outLst@[(m, Instr(l, bx c r))]) t\n\n            // MEMORY\n            | T_ADR c :: T_REG rd :: T_COMMA :: T_LABEL s :: t ->\n                parseRec (m+4) l labels (outLst@[(m, LabelRef(lsaRef l c rd s adr))]) t\n\n            // LOAD SINGLE\n            | T_LDR c :: T_REG rd :: T_COMMA :: T_L_BRAC :: T_REG rn :: T_R_BRAC :: T_COMMA :: T_REG rm :: T_COMMA :: T_SHIFT (z,_) :: t ->\n                match shiftMatch z t with\n                | Ok(ir,v,tail) -> parseRec (m+4) l labels (outLst@[(m, Instr(l, ldrWaR c rd rn rm z v ir))]) tail\n                | Err(_,s) -> Err(l,s)\n            | T_LDR c :: T_REG rd :: T_COMMA :: T_L_BRAC :: T_REG rn :: T_R_BRAC :: T_COMMA :: T_INT i :: t ->\n                match offset i with\n                | true -> parseRec (m+4) l labels (outLst@[(m, Instr(l, ldrWaI c rd rn i))]) t\n                | false -> invalidMemOffsetRange l i\n            | T_LDR c :: T_REG rd :: T_COMMA :: T_L_BRAC :: T_REG rn :: T_R_BRAC :: T_COMMA :: T_REG rm :: t ->\n                parseRec (m+4) l labels (outLst@[(m, Instr(l, ldrWaR c rd rn rm T_LSL 0 T_I))]) t\n\n            | T_LDRB c :: T_REG rd :: T_COMMA :: T_L_BRAC :: T_REG rn :: T_R_BRAC :: T_COMMA :: T_REG rm :: T_COMMA :: T_SHIFT (z,_) :: t ->\n                match shiftMatch z t with\n                | Ok(ir,v,tail) -> parseRec (m+4) l labels (outLst@[(m, Instr(l, ldrBaR c rd rn rm z v ir))]) tail\n                | Err(_,s) -> Err(l,s)\n            | T_LDRB c :: T_REG rd :: T_COMMA :: T_L_BRAC :: T_REG rn :: T_R_BRAC :: T_COMMA :: T_INT i :: t ->\n                match offset i with\n                | true -> parseRec (m+4) l labels (outLst@[(m, Instr(l, ldrBaI c rd rn i))]) t\n                | false -> invalidMemOffsetRange l i\n            | T_LDRB c :: T_REG rd :: T_COMMA :: T_L_BRAC :: T_REG rn :: T_R_BRAC :: T_COMMA :: T_REG rm :: t ->\n                parseRec (m+4) l labels (outLst@[(m, Instr(l, ldrBaR c rd rn rm T_LSL 0 T_I))]) t\n\n            | T_LDR c :: T_REG rd :: T_COMMA :: T_EQUAL :: T_LABEL s :: t ->\n                parseRec (m+4) l labels (outLst@[(m, LabelRef(lsaRef l c rd s ldrWL))]) t\n            | T_LDR c :: T_REG rd :: T_COMMA :: T_L_BRAC :: T_REG rn :: T_R_BRAC :: t ->\n                parseRec (m+4) l labels (outLst@[(m, Instr(l, ldrWbI c false rd rn 0))]) t\n            | T_LDR c :: T_REG rd :: T_COMMA :: T_L_BRAC :: T_REG rn :: T_COMMA :: T_INT i :: T_R_BRAC :: T_EXCL :: t ->\n                match offset i with\n                | true -> parseRec (m+4) l labels (outLst@[(m, Instr(l, ldrWbI c true rd rn i))]) t\n                | false -> invalidMemOffsetRange l i\n            | T_LDR c :: T_REG rd :: T_COMMA :: T_L_BRAC :: T_REG rn :: T_COMMA :: T_INT i :: T_R_BRAC :: t ->\n                match offset i with\n                | true -> parseRec (m+4) l labels (outLst@[(m, Instr(l, ldrWbI c false rd rn i))]) t\n                | false -> invalidMemOffsetRange l i\n            | T_LDR c :: T_REG rd :: T_COMMA :: T_L_BRAC :: T_REG rn :: T_COMMA :: T_REG rm :: T_R_BRAC :: T_EXCL :: t ->\n                parseRec (m+4) l labels (outLst@[(m, Instr(l, ldrWbR c true rd rn rm T_LSL 0 T_I))]) t\n            | T_LDR c :: T_REG rd :: T_COMMA :: T_L_BRAC :: T_REG rn :: T_COMMA :: T_REG rm :: T_R_BRAC :: t ->\n                parseRec (m+4) l labels (outLst@[(m, Instr(l, ldrWbR c false rd rn rm T_LSL 0 T_I))]) t\n            | T_LDR c :: T_REG rd :: T_COMMA :: T_L_BRAC :: T_REG rn :: T_COMMA :: T_REG rm :: T_COMMA :: T_SHIFT (z,_) :: t ->\n                match shiftMatch z t with\n                | Ok(ir,v,T_R_BRAC::T_EXCL::tail) -> parseRec (m+4) l labels (outLst@[(m, Instr(l, ldrWbR c true rd rn rm z v ir))]) tail\n                | Ok(ir,v,T_R_BRAC::tail) -> parseRec (m+4) l labels (outLst@[(m, Instr(l, ldrWbR c false rd rn rm z v ir))]) tail\n                | Ok(ir,v,tok::tail) -> unexpectedToken l tok tail\n                | Ok(ir,v,[]) -> invalidShiftMatch l\n                | Err(_,s) -> Err(l,s)\n\n            | T_LDRB c :: T_REG rd :: T_COMMA :: T_EQUAL :: T_LABEL s :: t ->\n                parseRec (m+4) l labels (outLst@[(m, LabelRef(lsaRef l c rd s ldrBL))]) t\n            | T_LDRB c :: T_REG rd :: T_COMMA :: T_L_BRAC :: T_REG rn :: T_R_BRAC :: t ->\n                parseRec (m+4) l labels (outLst@[(m, Instr(l, ldrBbI c false rd rn 0))]) t\n            | T_LDRB c :: T_REG rd :: T_COMMA :: T_L_BRAC :: T_REG rn :: T_COMMA :: T_INT i :: T_R_BRAC :: T_EXCL :: t ->\n                match offset i with\n                | true -> parseRec (m+4) l labels (outLst@[(m, Instr(l, ldrBbI c true rd rn i))]) t\n                | false -> invalidMemOffsetRange l i\n            | T_LDRB c :: T_REG rd :: T_COMMA :: T_L_BRAC :: T_REG rn :: T_COMMA :: T_INT i :: T_R_BRAC :: t ->\n                match offset i with\n                | true -> parseRec (m+4) l labels (outLst@[(m, Instr(l, ldrBbI c false rd rn i))]) t\n                | false -> invalidMemOffsetRange l i\n            | T_LDRB c :: T_REG rd :: T_COMMA :: T_L_BRAC :: T_REG rn :: T_COMMA :: T_REG rm :: T_R_BRAC :: T_EXCL :: t ->\n                parseRec (m+4) l labels (outLst@[(m, Instr(l, ldrBbR c true rd rn rm T_LSL 0 T_I))]) t\n            | T_LDRB c :: T_REG rd :: T_COMMA :: T_L_BRAC :: T_REG rn :: T_COMMA :: T_REG rm :: T_R_BRAC :: t ->\n                parseRec (m+4) l labels (outLst@[(m, Instr(l, ldrBbR c false rd rn rm T_LSL 0 T_I))]) t\n            | T_LDRB c :: T_REG rd :: T_COMMA :: T_L_BRAC :: T_REG rn :: T_COMMA :: T_REG rm :: T_COMMA :: T_SHIFT (z,_) :: t ->\n                match shiftMatch z t with\n                | Ok(ir,v,T_R_BRAC::T_EXCL::tail) -> parseRec (m+4) l labels (outLst@[(m, Instr(l, ldrBbR c true rd rn rm z v ir))]) tail\n                | Ok(ir,v,T_R_BRAC::tail) -> parseRec (m+4) l labels (outLst@[(m, Instr(l, ldrBbR c false rd rn rm z v ir))]) tail\n                | Ok(ir,v,tok::tail) -> unexpectedToken l tok tail\n                | Ok(ir,v,[]) -> invalidShiftMatch l\n                | Err(_,s) -> Err(l,s)\n\n            // STORE SINGLE\n            | T_STR c :: T_REG rd :: T_COMMA :: T_L_BRAC :: T_REG rn :: T_R_BRAC :: T_COMMA :: T_REG rm :: T_COMMA :: T_SHIFT (z,_) :: t ->\n                match shiftMatch z t with\n                | Ok(ir,v,tail) -> parseRec (m+4) l labels (outLst@[(m, Instr(l, strWaR c rd rn rm z v ir))]) tail\n                | Err(_,s) -> Err(l,s)\n            | T_STR c :: T_REG rd :: T_COMMA :: T_L_BRAC :: T_REG rn :: T_R_BRAC :: T_COMMA :: T_INT i :: t ->\n                match offset i with\n                | true -> parseRec (m+4) l labels (outLst@[(m, Instr(l, strWaI c rd rn i))]) t\n                | false -> invalidMemOffsetRange l i\n            | T_STR c :: T_REG rd :: T_COMMA :: T_L_BRAC :: T_REG rn :: T_R_BRAC :: T_COMMA :: T_REG rm :: t ->\n                parseRec (m+4) l labels (outLst@[(m, Instr(l, strWaR c rd rn rm T_LSL 0 T_I))]) t\n\n            | T_STRB c :: T_REG rd :: T_COMMA :: T_L_BRAC :: T_REG rn :: T_R_BRAC :: T_COMMA :: T_REG rm :: T_COMMA :: T_SHIFT (z,_) :: t ->\n                match shiftMatch z t with\n                | Ok(ir,v,tail) -> parseRec (m+4) l labels (outLst@[(m, Instr(l, strBaR c rd rn rm z v ir))]) tail\n                | Err(_,s) -> Err(l,s)\n            | T_STRB c :: T_REG rd :: T_COMMA :: T_L_BRAC :: T_REG rn :: T_R_BRAC :: T_COMMA :: T_INT i :: t ->\n            match offset i with\n                | true -> parseRec (m+4) l labels (outLst@[(m, Instr(l, strBaI c rd rn i))]) t\n                | false -> invalidMemOffsetRange l i\n            | T_STRB c :: T_REG rd :: T_COMMA :: T_L_BRAC :: T_REG rn :: T_R_BRAC :: T_COMMA :: T_REG rm :: t ->\n                parseRec (m+4) l labels (outLst@[(m, Instr(l, strBaR c rd rn rm T_LSL 0 T_I))]) t\n\n            | T_STR c :: T_REG rd :: T_COMMA :: T_L_BRAC :: T_REG rn :: T_R_BRAC :: t ->\n                parseRec (m+4) l labels (outLst@[(m, Instr(l, strWbI c false rd rn 0))]) t\n            | T_STR c :: T_REG rd :: T_COMMA :: T_L_BRAC :: T_REG rn :: T_COMMA :: T_INT i :: T_R_BRAC :: T_EXCL :: t ->\n                match offset i with\n                | true -> parseRec (m+4) l labels (outLst@[(m, Instr(l, strWbI c true rd rn i))]) t\n                | false -> invalidMemOffsetRange l i\n            | T_STR c :: T_REG rd :: T_COMMA :: T_L_BRAC :: T_REG rn :: T_COMMA :: T_INT i :: T_R_BRAC :: t ->\n                match offset i with\n                | true -> parseRec (m+4) l labels (outLst@[(m, Instr(l, strWbI c false rd rn i))]) t\n                | false -> invalidMemOffsetRange l i\n            | T_STR c :: T_REG rd :: T_COMMA :: T_L_BRAC :: T_REG rn :: T_COMMA :: T_REG rm :: T_R_BRAC :: T_EXCL :: t ->\n                parseRec (m+4) l labels (outLst@[(m, Instr(l, strWbR c true rd rn rm T_LSL 0 T_I))]) t\n            | T_STR c :: T_REG rd :: T_COMMA :: T_L_BRAC :: T_REG rn :: T_COMMA :: T_REG rm :: T_R_BRAC :: t ->\n                parseRec (m+4) l labels (outLst@[(m, Instr(l, strWbR c false rd rn rm T_LSL 0 T_I))]) t\n            | T_STR c :: T_REG rd :: T_COMMA :: T_L_BRAC :: T_REG rn :: T_COMMA :: T_REG rm :: T_COMMA :: T_SHIFT (z,_) :: t ->\n                match shiftMatch z t with\n                | Ok(ir,v,T_R_BRAC::T_EXCL::tail) -> parseRec (m+4) l labels (outLst@[(m, Instr(l, strWbR c true rd rn rm z v ir))]) tail\n                | Ok(ir,v,T_R_BRAC::tail) -> parseRec (m+4) l labels (outLst@[(m, Instr(l, strWbR c false rd rn rm z v ir))]) tail\n                | Ok(ir,v,tok::tail) -> unexpectedToken l tok tail\n                | Ok(ir,v,[]) -> invalidShiftMatch l\n                | Err(_,s) -> Err(l,s)\n\n            | T_STRB c :: T_REG rd :: T_COMMA :: T_L_BRAC :: T_REG rn :: T_R_BRAC :: t ->\n                parseRec (m+4) l labels (outLst@[(m, Instr(l, strBbI c false rd rn 0))]) t\n            | T_STRB c :: T_REG rd :: T_COMMA :: T_L_BRAC :: T_REG rn :: T_COMMA :: T_INT i :: T_R_BRAC :: T_EXCL :: t ->\n                match offset i with\n                | true -> parseRec (m+4) l labels (outLst@[(m, Instr(l, strBbI c true rd rn i))]) t\n                | false -> invalidMemOffsetRange l i\n            | T_STRB c :: T_REG rd :: T_COMMA :: T_L_BRAC :: T_REG rn :: T_COMMA :: T_INT i :: T_R_BRAC :: t ->\n                match offset i with\n                | true -> parseRec (m+4) l labels (outLst@[(m, Instr(l, strBbI c false rd rn i))]) t\n                | false -> invalidMemOffsetRange l i\n            | T_STRB c :: T_REG rd :: T_COMMA :: T_L_BRAC :: T_REG rn :: T_COMMA :: T_REG rm :: T_R_BRAC :: T_EXCL :: t ->\n                parseRec (m+4) l labels (outLst@[(m, Instr(l, strBbR c true rd rn rm T_LSL 0 T_I))]) t\n            | T_STRB c :: T_REG rd :: T_COMMA :: T_L_BRAC :: T_REG rn :: T_COMMA :: T_REG rm :: T_R_BRAC :: t ->\n                parseRec (m+4) l labels (outLst@[(m, Instr(l, strBbR c false rd rn rm T_LSL 0 T_I))]) t\n            | T_STRB c :: T_REG rd :: T_COMMA :: T_L_BRAC :: T_REG rn :: T_COMMA :: T_REG rm :: T_COMMA :: T_SHIFT (z,_) :: t ->\n                match shiftMatch z t with\n                | Ok(ir,v,T_R_BRAC::T_EXCL::tail) -> parseRec (m+4) l labels (outLst@[(m, Instr(l, strBbR c true rd rn rm z v ir))]) tail\n                | Ok(ir,v,T_R_BRAC::tail) -> parseRec (m+4) l labels (outLst@[(m, Instr(l, strBbR c false rd rn rm z v ir))]) tail\n                | Ok(ir,v,tok::tail) -> unexpectedToken l tok tail\n                | Ok(ir,v,[]) -> invalidShiftMatch l\n                | Err(_,s) -> Err(l,s)\n\n            // LOAD MULTIPLE\n            | T_LDM (c,S_IA) :: T_REG rn :: T_COMMA :: t ->\n                match regList t with\n                | Ok(rl, tokLst) -> parseRec (m+4) l labels (outLst@[(m, Instr(l, ldmIA c false rn rl))]) tokLst\n                | Err(_,s) -> Err(l,s)\n            | T_LDM (c,S_IA) :: T_REG rn :: T_EXCL :: T_COMMA :: t ->\n                match regList t with\n                | Ok(rl, tokLst) -> parseRec (m+4) l labels (outLst@[(m, Instr(l, ldmIA c true rn rl))]) tokLst\n                | Err(_,s) -> Err(l,s)\n            | T_LDM (c,S_IB) :: T_REG rn :: T_COMMA :: t ->\n                match regList t with\n                | Ok(rl, tokLst) -> parseRec (m+4) l labels (outLst@[(m, Instr(l, ldmIB c false rn rl))]) tokLst\n                | Err(_,s) -> Err(l,s)\n            | T_LDM (c,S_IB) :: T_REG rn :: T_EXCL :: T_COMMA :: t ->\n                match regList t with\n                | Ok(rl, tokLst) -> parseRec (m+4) l labels (outLst@[(m, Instr(l, ldmIB c true rn rl))]) tokLst\n                | Err(_,s) -> Err(l,s)\n            | T_LDM (c,S_DA) :: T_REG rn :: T_COMMA :: t ->\n                match regList t with\n                | Ok(rl, tokLst) -> parseRec (m+4) l labels (outLst@[(m, Instr(l, ldmDA c false rn rl))]) tokLst\n                | Err(_,s) -> Err(l,s)\n            | T_LDM (c,S_DA) :: T_REG rn :: T_EXCL :: T_COMMA :: t ->\n                match regList t with\n                | Ok(rl, tokLst) -> parseRec (m+4) l labels (outLst@[(m, Instr(l, ldmDA c true rn rl))]) tokLst\n                | Err(_,s) -> Err(l,s)\n            | T_LDM (c,S_DB) :: T_REG rn :: T_COMMA :: t ->\n                match regList t with\n                | Ok(rl, tokLst) -> parseRec (m+4) l labels (outLst@[(m, Instr(l, ldmDB c false rn rl))]) tokLst\n                | Err(_,s) -> Err(l,s)\n            | T_LDM (c,S_DB) :: T_REG rn :: T_EXCL :: T_COMMA :: t ->\n                match regList t with\n                | Ok(rl, tokLst) -> parseRec (m+4) l labels (outLst@[(m, Instr(l, ldmDB c true rn rl))]) tokLst\n                | Err(_,s) -> Err(l,s)\n\n            // STORE MULTIPLE\n            | T_STM (c,S_IA) :: T_REG rn :: T_COMMA :: t ->\n                match regList t with\n                | Ok(rl, tokLst) -> parseRec (m+4) l labels (outLst@[(m, Instr(l, stmIA c false rn rl))]) tokLst\n                | Err(_,s) -> Err(l,s)\n            | T_STM (c,S_IA) :: T_REG rn :: T_EXCL :: T_COMMA :: t ->\n                match regList t with\n                | Ok(rl, tokLst) -> parseRec (m+4) l labels (outLst@[(m, Instr(l, stmIA c true rn rl))]) tokLst\n                | Err(_,s) -> Err(l,s)\n            | T_STM (c,S_IB) :: T_REG rn :: T_COMMA :: t ->\n                match regList t with\n                | Ok(rl, tokLst) -> parseRec (m+4) l labels (outLst@[(m, Instr(l, stmIB c false rn rl))]) tokLst\n                | Err(_,s) -> Err(l,s)\n            | T_STM (c,S_IB) :: T_REG rn :: T_EXCL :: T_COMMA :: t ->\n                match regList t with\n                | Ok(rl, tokLst) -> parseRec (m+4) l labels (outLst@[(m, Instr(l, stmIB c true rn rl))]) tokLst\n                | Err(_,s) -> Err(l,s)\n            | T_STM (c,S_DA) :: T_REG rn :: T_COMMA :: t ->\n                match regList t with\n                | Ok(rl, tokLst) -> parseRec (m+4) l labels (outLst@[(m, Instr(l, stmDA c false rn rl))]) tokLst\n                | Err(_,s) -> Err(l,s)\n            | T_STM (c,S_DA) :: T_REG rn :: T_EXCL :: T_COMMA :: t ->\n                match regList t with\n                | Ok(rl, tokLst) -> parseRec (m+4) l labels (outLst@[(m, Instr(l, stmDA c true rn rl))]) tokLst\n                | Err(_,s) -> Err(l,s)\n            | T_STM (c,S_DB) :: T_REG rn :: T_COMMA :: t ->\n                match regList t with\n                | Ok(rl, tokLst) -> parseRec (m+4) l labels (outLst@[(m, Instr(l, stmDB c false rn rl))]) tokLst\n                | Err(_,s) -> Err(l,s)\n            | T_STM (c,S_DB) :: T_REG rn :: T_EXCL :: T_COMMA :: t ->\n                match regList t with\n                | Ok(rl, tokLst) -> parseRec (m+4) l labels (outLst@[(m, Instr(l, stmDB c true rn rl))]) tokLst\n                | Err(_,s) -> Err(l,s)\n\n            // DIRECTIVES\n            | T_LABEL s :: T_EQU :: T_INT i :: t ->\n                parseRec m l (Map.add s i labels) outLst t\n            | T_LABEL s1 :: T_EQU :: T_LABEL s2 :: t ->\n                match Map.tryFind s2 labels with\n                | Some(n) -> parseRec m l (Map.add s1 n labels) outLst t\n                | None -> undefinedLabel l s2\n\n            //| T_LABEL \n\n            | T_END c :: t ->\n                parseRec (m+4) l labels (outLst@[(m, EndRef(endRef l c))]) t\n\n            | T_LABEL s :: t -> parseRec m l (Map.add s (m) labels) outLst t\n\n            | [] -> resolveRefs labels m (outLst@[(m, Terminate(l))])\n\n            | T_NEWLINE :: t -> parseRec m (l+1) labels outLst t\n\n            | T_ERROR s :: t -> invalidToken l s\n            | tok :: t -> unexpectedToken l tok t\n        // Convert output list to map for interpretation.\n        match parseRec 0 1 Map.empty [] tokLst with\n        | Ok(i) -> Ok(Map.ofList i)\n        | Err(l,s) -> Err(l,s)","﻿// This module details the instruction condition codes.\n\nnamespace Common\nmodule Conditions =\n    \n    open State\n\n    // Condition functions\n    /// Always condition.\n    let checkAL state =\n        true\n\n    /// Equal condition.\n    let checkEQ state =\n        readZFlag state\n\n    /// Not equal condition.\n    let checkNE state =\n        not (readZFlag state)\n\n    /// Carry set condition.\n    let checkCS state =\n        readCFlag state\n\n    /// Carry clear condition.\n    let checkCC state =\n        not (readCFlag state)\n\n    /// Minus condition.\n    let checkMI state =\n        readNFlag state\n\n    /// Plus condition.\n    let checkPL state =\n        not (readNFlag state)\n\n    /// Overflow set condition\n    let checkVS state =\n        readVFlag state\n\n    /// Overflow clear condition\n    let checkVC state =\n        not (readVFlag state)\n\n    /// HI condition.\n    let checkHI state =\n        (readCFlag state) && (not (readZFlag state))\n\n    /// LS condition.\n    let checkLS state =\n        (not (readCFlag state)) || (readZFlag state)\n\n    /// Greater than or equal condition.\n    let checkGE state =\n        (readNFlag state) = (readVFlag state)\n\n    /// Less than condition.\n    let checkLT state =\n        (readNFlag state) <> (readVFlag state)\n\n    /// Greater than condition.\n    let checkGT state =\n        (not (readZFlag state)) && ((readNFlag state) = (readVFlag state))\n\n    /// Less than or equal condition.\n    let checkLE state =\n        (readZFlag state) && ((readNFlag state) <> (readVFlag state))","﻿// This module contains the tokeniser\n\nnamespace Parse\nmodule Tokeniser =\n    \n    open System.Text.RegularExpressions\n    open Common.Conditions\n    open Common.State\n    open Common.Types\n       \n    \n    (***TOKENS***)\n    // To add token:\n        // Add to discriminated union\n        // Add to equals override\n        // Add to stringToToken function\n\n    \n    /// Add tokens here! Format: \"T_x\"\n    [<CustomEquality; NoComparison>]\n    type Token =\n        // Instructions:\n            // All of these have a condition function, some have 'S' bool\n        | T_MOV of (StateHandle -> bool)*bool\n        | T_MVN of (StateHandle -> bool)*bool\n        | T_MRS of (StateHandle -> bool)\n        | T_MSR of (StateHandle -> bool)\n\n        | T_ADD of (StateHandle -> bool)*bool\n        | T_ADC of (StateHandle -> bool)*bool\n        | T_SUB of (StateHandle -> bool)*bool\n        | T_SBC of (StateHandle -> bool)*bool\n        | T_RSB of (StateHandle -> bool)*bool\n        | T_RSC of (StateHandle -> bool)*bool\n\n        | T_MUL of (StateHandle -> bool)*bool\n        | T_MLA of (StateHandle -> bool)*bool\n        | T_UMULL of (StateHandle -> bool)*bool\n        | T_UMLAL of (StateHandle -> bool)*bool\n        | T_SMULL of (StateHandle -> bool)*bool\n        | T_SMLAL of (StateHandle -> bool)*bool\n\n        | T_AND of (StateHandle -> bool)*bool\n        | T_ORR of (StateHandle -> bool)*bool\n        | T_EOR of (StateHandle -> bool)*bool\n        | T_BIC of (StateHandle -> bool)*bool\n\n        | T_CMP of (StateHandle -> bool)\n        | T_CMN of (StateHandle -> bool)\n        | T_TST of (StateHandle -> bool)\n        | T_TEQ of (StateHandle -> bool)\n\n        | T_B of (StateHandle -> bool)\n        | T_BL of (StateHandle -> bool)\n        | T_BX of (StateHandle -> bool)\n\n        | T_LDR of (StateHandle -> bool)\n        | T_LDRB of (StateHandle -> bool)\n        | T_LDRH of (StateHandle -> bool)\n        | T_LDM of (StateHandle -> bool)*stackOrder\n\n        | T_STR of (StateHandle -> bool)\n        | T_STRB of (StateHandle -> bool)\n        | T_STRH of (StateHandle -> bool)\n        | T_STM of (StateHandle -> bool)*stackOrder\n\n        | T_ADR of (StateHandle -> bool)\n        | T_SWP of (StateHandle -> bool)\n        | T_SWI of (StateHandle -> bool)\n        | T_NOP of (StateHandle -> bool)\n        | T_CLZ of (StateHandle -> bool)\n\n        // Directives\n        | T_DCD\n        | T_EQU\n        | T_FILL\n        | T_END of (StateHandle -> bool)\n        // shift operands\n        | T_SHIFT of shiftOp*((StateHandle -> bool)*bool)\n        // Values\n        | T_REG of int\n        | T_INT of int\n        | T_LABEL of string\n        // Others\n        | T_COMMA\n        | T_L_BRAC\n        | T_R_BRAC\n        | T_EXCL\n        | T_EQUAL\n        | T_L_CBR\n        | T_R_CBR\n        | T_DASH\n        | T_NEWLINE\n        | T_ERROR of string\n\n        // Equals for testing.\n        override x.Equals yobj =\n            let state = initState\n            match yobj with\n            | :? Token as y -> match x,y with\n                               | T_REG ix, T_REG iy -> ix = iy\n                               | T_INT ix, T_INT iy -> ix = iy\n                               | T_LABEL sx, T_LABEL sy -> sx = sy\n\n                               | T_COMMA, T_COMMA -> true\n                               | T_L_BRAC, T_L_BRAC -> true\n                               | T_R_BRAC, T_R_BRAC -> true\n                               | T_EXCL, T_EXCL -> true\n                               | T_L_CBR, T_R_CBR -> true\n                               | T_DASH, T_DASH -> true\n                               | T_NEWLINE, T_NEWLINE -> true\n                               | T_ERROR tx, T_ERROR ty -> tx = ty\n\n                               | T_MOV (cx,sx), T_MOV (cy,sy) -> cx state = cy state && sx = sy\n                               | T_MVN (cx,sx), T_MVN (cy,sy) -> cx state = cy state && sx = sy\n                               | T_MRS cx, T_MRS cy -> cx state = cy state\n                               | T_MSR cx, T_MSR cy -> cx state = cy state\n                               | T_ADD (cx,sx), T_ADD (cy,sy) -> cx state = cy state && sx = sy\n                               | T_ADC (cx,sx), T_ADC (cy,sy) -> cx state = cy state && sx = sy\n                               | T_SUB (cx,sx), T_SUB (cy,sy) -> cx state = cy state && sx = sy\n                               | T_SBC (cx,sx), T_SBC (cy,sy) -> cx state = cy state && sx = sy\n                               | T_RSB (cx,sx), T_RSB (cy,sy) -> cx state = cy state && sx = sy\n                               | T_RSC (cx,sx), T_RSC (cy,sy) -> cx state = cy state && sx = sy\n                               | T_MUL (cx,sx), T_MUL (cy,sy) -> cx state = cy state && sx = sy\n                               | T_MLA (cx,sx), T_MLA (cy,sy) -> cx state = cy state && sx = sy\n                               | T_AND (cx,sx), T_AND (cy,sy) -> cx state = cy state && sx = sy\n                               | T_ORR (cx,sx), T_ORR (cy,sy) -> cx state = cy state && sx = sy\n                               | T_EOR (cx,sx), T_EOR (cy,sy) -> cx state = cy state && sx = sy\n                               | T_BIC (cx,sx), T_BIC (cy,sy) -> cx state = cy state && sx = sy\n                               | T_CMP cx, T_CMP cy -> cx state = cy state\n                               | T_CMN cx, T_CMN cy -> cx state = cy state\n                               | T_TST cx, T_TST cy -> cx state = cy state\n                               | T_TEQ cx, T_TEQ cy -> cx state = cy state\n                               | T_B cx, T_B cy -> cx state = cy state\n                               | T_BL cx, T_BL cy -> cx state = cy state\n                               | T_BX cx, T_BX cy -> cx state = cy state\n                               | T_LDR cx, T_LDR cy -> cx state = cy state\n                               | T_LDRB cx, T_LDRB cy -> cx state = cy state\n                               | T_LDRH cx, T_LDRH cy -> cx state = cy state\n                               | T_LDM (cx,sx), T_LDM (cy,sy) -> cx state = cy state && sx = sy\n                               | T_STR cx, T_STR cy -> cx state = cy state\n                               | T_STRB cx, T_STRB cy -> cx state = cy state\n                               | T_STRH cx, T_STRH cy -> cx state = cy state\n                               | T_STM (cx,sx), T_STM (cy,sy) -> cx state = cy state && sx = sy\n                               | T_ADR cx, T_ADR cy -> cx state = cy state\n                               | T_SWP cx, T_SWP cy -> cx state = cy state\n                               | T_SWI cx, T_SWI cy -> cx state = cy state\n                               | T_NOP cx, T_NOP cy -> cx state = cy state\n                               | T_CLZ cx, T_CLZ cy -> cx state = cy state\n                               | T_DCD, T_DCD -> true\n                               | T_EQU, T_EQU -> true\n                               | T_FILL, T_FILL -> true\n                               | T_END cx, T_END cy -> cx state = cy state\n                               | T_SHIFT (tx,(cx,sx)), T_SHIFT (ty,(cy,sy)) -> tx = ty && cx state = cy state && sx = sy\n                               | _,_ -> false\n            | _ -> false\n\n        override x.GetHashCode() = hash 1 // To avoid warnings! I advise not hashing tokens.\n\n    (***SUFFIXES***)\n\n    /// Instruction condition codes.\n    let cond = @\"(|EQ|NE|CS|HS|CC|LO|MI|PL|VS|VC|HI|LS|GE|LT|GT|LE|AL)\"\n\n    /// S suffix, for setting flags.\n    let setFlags = @\"(|S)\"\n\n    /// Stack suffix, for load/store multiple\n    let stackSfx = @\"(IA|IB|DA|DB|FD|FA|ED|EA)\"\n\n    (***TOKENISER***)\n\n    // active patterns for matching strings\n\n    // match generic token with no output.\n    let (|TOKEN_MATCH|_|) pattern str =\n        let m = Regex.Match(str, pattern, RegexOptions.IgnoreCase)\n        if m.Success then Some() else None\n\n    /// Match input string to condition code.\n    let matchCond = function\n        | TOKEN_MATCH \"EQ\" -> checkEQ\n        | TOKEN_MATCH \"NE\" -> checkNE\n        | TOKEN_MATCH \"CS\" -> checkCS\n        | TOKEN_MATCH \"HS\" -> checkCS\n        | TOKEN_MATCH \"CC\" -> checkCC\n        | TOKEN_MATCH \"LO\" -> checkCC\n        | TOKEN_MATCH \"MI\" -> checkMI\n        | TOKEN_MATCH \"PL\" -> checkPL\n        | TOKEN_MATCH \"VS\" -> checkVS\n        | TOKEN_MATCH \"VC\" -> checkVC\n        | TOKEN_MATCH \"HI\" -> checkHI\n        | TOKEN_MATCH \"GE\" -> checkGE\n        | TOKEN_MATCH \"LT\" -> checkLT\n        | TOKEN_MATCH \"GT\" -> checkGT\n        | TOKEN_MATCH \"LE\" -> checkLE\n        | TOKEN_MATCH \"AL\" -> checkAL\n        | _ -> checkAL\n\n    /// Match 'S' suffix to bool.\n    let matchS = function\n        | TOKEN_MATCH \"S\" -> true\n        | _ -> false\n\n    /// Match LDM suffix to stackOrder.\n    let matchLDM = function\n        | TOKEN_MATCH \"IA\" -> S_IA\n        | TOKEN_MATCH \"IB\" -> S_IB\n        | TOKEN_MATCH \"DA\" -> S_DA\n        | TOKEN_MATCH \"DB\" -> S_DB\n        | TOKEN_MATCH \"FD\" -> S_IA\n        | TOKEN_MATCH \"ED\" -> S_IB\n        | TOKEN_MATCH \"FA\" -> S_DA\n        | TOKEN_MATCH \"EA\" -> S_DB\n        | _ -> S_IA\n\n    /// Match STM suffix to stackOrder.\n    let matchSTM = function\n        | TOKEN_MATCH \"IA\" -> S_IA\n        | TOKEN_MATCH \"IB\" -> S_IB\n        | TOKEN_MATCH \"DA\" -> S_DA\n        | TOKEN_MATCH \"DB\" -> S_DB\n        | TOKEN_MATCH \"EA\" -> S_IA\n        | TOKEN_MATCH \"FA\" -> S_IB\n        | TOKEN_MATCH \"ED\" -> S_DA\n        | TOKEN_MATCH \"FD\" -> S_DB\n        | _ -> S_IA\n\n    // match an instruction (with condition code)\n    let (|INSTR_MATCH|_|) pattern str =\n        let m = Regex.Match(str, pattern+cond+\"$\", RegexOptions.IgnoreCase)\n        if m.Success then Some(matchCond m.Groups.[1].Value) else None\n\n    // match an instruction with condition code AND 's' suffix (for setting flags)\n    let (|INSTR_S_MATCH|_|) pattern str =\n        let m = Regex.Match(str, pattern+cond+setFlags+\"$\", RegexOptions.IgnoreCase)\n        if m.Success then Some(matchCond m.Groups.[1].Value, matchS m.Groups.[2].Value) else None\n\n    // match load multiple instruction with stack suffix.\n    let (|LDM_MATCH|_|) str =\n        let m = Regex.Match(str, @\"^LDM\"+stackSfx+cond+\"$\", RegexOptions.IgnoreCase)\n        if m.Success then Some(matchCond m.Groups.[1].Value, matchLDM m.Groups.[2].Value) else None\n        \n    // match load multiple instruction with stack suffix.\n    let (|STM_MATCH|_|) str =\n        let m = Regex.Match(str, @\"^STM\"+stackSfx+cond+\"$\", RegexOptions.IgnoreCase)\n        if m.Success then Some(matchCond m.Groups.[1].Value, matchSTM m.Groups.[2].Value) else None\n\n    // match a valid register\n    let (|REG_MATCH|_|) str =\n        let m = Regex.Match(str, @\"^R([0-9]|1[0-5])$\", RegexOptions.IgnoreCase)\n        if m.Success then Some(int m.Groups.[1].Value) else None\n\n    let (|LABEL_MATCH|_|) str =\n        let m = Regex.Match(str, @\"^([a-zA-Z_][a-zA-Z0-9_]*)$\")\n        if m.Success then Some(m.Groups.[1].Value) else None\n\n    let (|DEC_LIT_MATCH|_|) str =\n        let m = Regex.Match(str, @\"^#?([0-9]+)$\")\n        if m.Success then Some(int(uint32 m.Groups.[1].Value)) else None\n        \n    let (|DEC_S_LIT_MATCH|_|) str =\n        let m = Regex.Match(str, @\"^#?(-[0-9]+)$\")\n        if m.Success then Some(int m.Groups.[1].Value) else None\n\n    let (|HEX_LIT_MATCH|_|) str =\n        let m = Regex.Match(str, @\"^#?(0x[0-9a-fA-F]+)$\")\n        if m.Success then Some(System.Convert.ToInt32 (m.Groups.[1].Value, 16)) else None\n\n    \n    /// Match input string to token.\n    let private stringToToken = function\n        // registers & aliases\n        | REG_MATCH i -> T_REG i\n        | TOKEN_MATCH @\"^a1$\" -> T_REG 0\n        | TOKEN_MATCH @\"^a2$\" -> T_REG 1\n        | TOKEN_MATCH @\"^a3$\" -> T_REG 2\n        | TOKEN_MATCH @\"^a4$\" -> T_REG 3\n        | TOKEN_MATCH @\"^v1$\" -> T_REG 4\n        | TOKEN_MATCH @\"^v2$\" -> T_REG 5\n        | TOKEN_MATCH @\"^v3$\" -> T_REG 6\n        | TOKEN_MATCH @\"^v4$\" -> T_REG 7\n        | TOKEN_MATCH @\"^v5$\" -> T_REG 8\n        | TOKEN_MATCH @\"^v6$\" -> T_REG 9\n        | TOKEN_MATCH @\"^v7$\" -> T_REG 10\n        | TOKEN_MATCH @\"^v8$\" -> T_REG 11\n        | TOKEN_MATCH @\"^sb$\" -> T_REG 9\n        | TOKEN_MATCH @\"^sl$\" -> T_REG 10\n        | TOKEN_MATCH @\"^fp$\" -> T_REG 11\n        | TOKEN_MATCH @\"^ip$\" -> T_REG 12\n        | TOKEN_MATCH @\"^sp$\" -> T_REG 13\n        | TOKEN_MATCH @\"^lr$\" -> T_REG 14\n        | TOKEN_MATCH @\"^pc$\" -> T_REG 15\n        // other\n        | \",\" -> T_COMMA\n        | \"[\" -> T_L_BRAC\n        | \"]\" -> T_R_BRAC\n        | \"!\" -> T_EXCL\n        | \"=\" -> T_EQUAL\n        | \"{\" -> T_L_CBR\n        | \"}\" -> T_R_CBR\n        | \"-\" -> T_DASH\n        | \"\\n\" -> T_NEWLINE\n        | DEC_LIT_MATCH i -> T_INT i\n        | DEC_S_LIT_MATCH i -> T_INT i\n        | HEX_LIT_MATCH i -> T_INT i\n        // instructions\n        | INSTR_S_MATCH @\"^MOV\" cs -> T_MOV cs\n        | INSTR_S_MATCH @\"^MVN\" cs -> T_MVN cs\n        | INSTR_MATCH @\"^MRS\" c -> T_MRS c\n        | INSTR_MATCH @\"^MSR\" c -> T_MSR c\n        | INSTR_S_MATCH @\"^ADD\" cs -> T_ADD cs\n        | INSTR_S_MATCH @\"^ADC\" cs -> T_ADC cs\n        | INSTR_S_MATCH @\"^SUB\" cs -> T_SUB cs\n        | INSTR_S_MATCH @\"^SBC\" cs -> T_SBC cs\n        | INSTR_S_MATCH @\"^RSB\" cs -> T_RSB cs\n        | INSTR_S_MATCH @\"^RSC\" cs -> T_RSC cs\n        | INSTR_S_MATCH @\"^MUL\" cs -> T_MUL cs\n        | INSTR_S_MATCH @\"^MLA\" cs -> T_MLA cs\n        | INSTR_S_MATCH @\"^UMULL\" cs -> T_UMULL cs\n        | INSTR_S_MATCH @\"^UMLAL\" cs -> T_UMLAL cs\n        | INSTR_S_MATCH @\"^SMULL\" cs -> T_SMULL cs\n        | INSTR_S_MATCH @\"^SMLAL\" cs -> T_SMLAL cs\n        | INSTR_S_MATCH @\"^AND\" cs -> T_AND cs\n        | INSTR_S_MATCH @\"^ORR\" cs -> T_ORR cs\n        | INSTR_S_MATCH @\"^EOR\" cs -> T_EOR cs\n        | INSTR_S_MATCH @\"^BIC\" cs -> T_BIC cs\n        | INSTR_MATCH @\"^CMP\" c -> T_CMP c\n        | INSTR_MATCH @\"^CMN\" c -> T_CMN c\n        | INSTR_MATCH @\"^TST\" c -> T_TST c\n        | INSTR_MATCH @\"^TEQ\" c -> T_TEQ c\n        | INSTR_MATCH @\"^B\" c -> T_B c\n        | INSTR_MATCH @\"^BL\" c -> T_BL c\n        | INSTR_MATCH @\"^BX\" c -> T_BX c\n        | INSTR_MATCH @\"^LDR\" c -> T_LDR c\n        | INSTR_MATCH @\"^LDRB\" c -> T_LDRB c\n        | INSTR_MATCH @\"^LDRH\" c -> T_LDRH c\n        | LDM_MATCH cs -> T_LDM cs\n        | INSTR_MATCH @\"^STR\" c -> T_STR c\n        | INSTR_MATCH @\"^STRB\" c -> T_STRB c\n        | INSTR_MATCH @\"^STRH\" c -> T_STRH c\n        | STM_MATCH cs -> T_STM cs\n        | INSTR_MATCH @\"^SWP\" c -> T_SWP c\n        | INSTR_MATCH @\"^SWI\" c -> T_SWI c\n        | INSTR_MATCH @\"^NOP\" c -> T_NOP c\n        | INSTR_MATCH @\"^ADR\" c -> T_ADR c\n        | INSTR_MATCH @\"^END\" c -> T_END c\n        | INSTR_MATCH @\"^CLZ\" c -> T_CLZ c\n        | TOKEN_MATCH @\"^DCD$\" -> T_DCD\n        | TOKEN_MATCH @\"^EQU$\" -> T_EQU\n        | TOKEN_MATCH @\"^FILL$\" -> T_FILL\n        // shift operands\n        | INSTR_S_MATCH @\"^ASR\" cs -> T_SHIFT (T_ASR, cs)\n        | INSTR_S_MATCH @\"^LSL\" cs -> T_SHIFT (T_LSL, cs)\n        | INSTR_S_MATCH @\"^LSR\" cs -> T_SHIFT (T_LSR, cs)\n        | INSTR_S_MATCH @\"^ROR\" cs -> T_SHIFT (T_ROR, cs)\n        | INSTR_S_MATCH @\"^RRX\" cs -> T_SHIFT (T_RRX, cs)\n        // labels\n        | LABEL_MATCH s -> T_LABEL s\n        //| t -> failwithf \"Invalid token %A\" t\n        | t -> T_ERROR t\n\n\n    /// Take in string and output list of tokens.\n    let tokenise (source: string) =\n        Regex.Split(source, @\"([,\\[\\]!\\n])|[\\ \\t\\r\\f]+|;.*\")\n        |> Array.toList\n        |> List.filter (fun s -> s <> null)\n        |> List.filter (fun s -> s <> \"\")\n        |> List.map stringToToken","﻿namespace Execute\nopen Common.State\nopen Parse\nopen Interpret\nopen Common.Error\n\nmodule GetStates =\n\n    let newStateAll oldState inString = inString |> Tokeniser.tokenise |> Parser.parser |> wrapErr (Interpreter.interpret oldState)\n    let newStateSingle oldState inString = inString |> Tokeniser.tokenise |> Parser.parser |> wrapErr (Interpreter.interpretLine oldState)","import List from \"./List\";\r\nimport { ofArray as listOfArray } from \"./List\";\r\nimport { toString } from \"./Util\";\r\nimport GenericComparer from \"./GenericComparer\";\r\nimport FSymbol from \"./Symbol\";\r\nimport { iterate as seqIterate } from \"./Seq\";\r\nimport { fold as seqFold } from \"./Seq\";\r\nimport { reduce as seqReduce } from \"./Seq\";\r\nimport { forAll as seqForAll } from \"./Seq\";\r\nimport { exists as seqExists } from \"./Seq\";\r\nimport { choose as seqChoose } from \"./Seq\";\r\nimport { scan as seqScan } from \"./Seq\";\r\nexport function distinctBy(f, xs) {\r\n    return seqChoose(function (tup) { return tup[0]; }, seqScan(function (tup, x) {\r\n        var acc = tup[1];\r\n        var k = f(x);\r\n        return acc.has(k) ? [null, acc] : [x, add(k, acc)];\r\n    }, [null, create()], xs));\r\n}\r\nexport function distinct(xs) {\r\n    return distinctBy(function (x) { return x; }, xs);\r\n}\r\nvar SetTree = (function () {\r\n    function SetTree(caseName, fields) {\r\n        this.Case = caseName;\r\n        this.Fields = fields;\r\n    }\r\n    return SetTree;\r\n}());\r\nexport { SetTree };\r\nvar tree_tolerance = 2;\r\nfunction tree_countAux(s, acc) {\r\n    return s.Case === \"SetOne\" ? acc + 1 : s.Case === \"SetEmpty\" ? acc : tree_countAux(s.Fields[1], tree_countAux(s.Fields[2], acc + 1));\r\n}\r\nfunction tree_count(s) {\r\n    return tree_countAux(s, 0);\r\n}\r\nfunction tree_SetOne(n) {\r\n    return new SetTree(\"SetOne\", [n]);\r\n}\r\nfunction tree_SetNode(x, l, r, h) {\r\n    return new SetTree(\"SetNode\", [x, l, r, h]);\r\n}\r\nfunction tree_height(t) {\r\n    return t.Case === \"SetOne\" ? 1 : t.Case === \"SetNode\" ? t.Fields[3] : 0;\r\n}\r\nfunction tree_mk(l, k, r) {\r\n    var matchValue = [l, r];\r\n    var $target1 = function () {\r\n        var hl = tree_height(l);\r\n        var hr = tree_height(r);\r\n        var m = hl < hr ? hr : hl;\r\n        return tree_SetNode(k, l, r, m + 1);\r\n    };\r\n    if (matchValue[0].Case === \"SetEmpty\") {\r\n        if (matchValue[1].Case === \"SetEmpty\") {\r\n            return tree_SetOne(k);\r\n        }\r\n        else {\r\n            return $target1();\r\n        }\r\n    }\r\n    else {\r\n        return $target1();\r\n    }\r\n}\r\nfunction tree_rebalance(t1, k, t2) {\r\n    var t1h = tree_height(t1);\r\n    var t2h = tree_height(t2);\r\n    if (t2h > t1h + tree_tolerance) {\r\n        if (t2.Case === \"SetNode\") {\r\n            if (tree_height(t2.Fields[1]) > t1h + 1) {\r\n                if (t2.Fields[1].Case === \"SetNode\") {\r\n                    return tree_mk(tree_mk(t1, k, t2.Fields[1].Fields[1]), t2.Fields[1].Fields[0], tree_mk(t2.Fields[1].Fields[2], t2.Fields[0], t2.Fields[2]));\r\n                }\r\n                else {\r\n                    throw new Error(\"rebalance\");\r\n                }\r\n            }\r\n            else {\r\n                return tree_mk(tree_mk(t1, k, t2.Fields[1]), t2.Fields[0], t2.Fields[2]);\r\n            }\r\n        }\r\n        else {\r\n            throw new Error(\"rebalance\");\r\n        }\r\n    }\r\n    else {\r\n        if (t1h > t2h + tree_tolerance) {\r\n            if (t1.Case === \"SetNode\") {\r\n                if (tree_height(t1.Fields[2]) > t2h + 1) {\r\n                    if (t1.Fields[2].Case === \"SetNode\") {\r\n                        return tree_mk(tree_mk(t1.Fields[1], t1.Fields[0], t1.Fields[2].Fields[1]), t1.Fields[2].Fields[0], tree_mk(t1.Fields[2].Fields[2], k, t2));\r\n                    }\r\n                    else {\r\n                        throw new Error(\"rebalance\");\r\n                    }\r\n                }\r\n                else {\r\n                    return tree_mk(t1.Fields[1], t1.Fields[0], tree_mk(t1.Fields[2], k, t2));\r\n                }\r\n            }\r\n            else {\r\n                throw new Error(\"rebalance\");\r\n            }\r\n        }\r\n        else {\r\n            return tree_mk(t1, k, t2);\r\n        }\r\n    }\r\n}\r\nfunction tree_add(comparer, k, t) {\r\n    if (t.Case === \"SetOne\") {\r\n        var c = comparer.Compare(k, t.Fields[0]);\r\n        if (c < 0) {\r\n            return tree_SetNode(k, new SetTree(\"SetEmpty\", []), t, 2);\r\n        }\r\n        else if (c === 0) {\r\n            return t;\r\n        }\r\n        else {\r\n            return tree_SetNode(k, t, new SetTree(\"SetEmpty\", []), 2);\r\n        }\r\n    }\r\n    else if (t.Case === \"SetEmpty\") {\r\n        return tree_SetOne(k);\r\n    }\r\n    else {\r\n        var c = comparer.Compare(k, t.Fields[0]);\r\n        if (c < 0) {\r\n            return tree_rebalance(tree_add(comparer, k, t.Fields[1]), t.Fields[0], t.Fields[2]);\r\n        }\r\n        else if (c === 0) {\r\n            return t;\r\n        }\r\n        else {\r\n            return tree_rebalance(t.Fields[1], t.Fields[0], tree_add(comparer, k, t.Fields[2]));\r\n        }\r\n    }\r\n}\r\nfunction tree_balance(comparer, t1, k, t2) {\r\n    var matchValue = [t1, t2];\r\n    var $target1 = function (t1_1) { return tree_add(comparer, k, t1_1); };\r\n    var $target2 = function (k1, t2_1) { return tree_add(comparer, k, tree_add(comparer, k1, t2_1)); };\r\n    if (matchValue[0].Case === \"SetOne\") {\r\n        if (matchValue[1].Case === \"SetEmpty\") {\r\n            return $target1(matchValue[0]);\r\n        }\r\n        else {\r\n            if (matchValue[1].Case === \"SetOne\") {\r\n                return $target2(matchValue[0].Fields[0], matchValue[1]);\r\n            }\r\n            else {\r\n                return $target2(matchValue[0].Fields[0], matchValue[1]);\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        if (matchValue[0].Case === \"SetNode\") {\r\n            if (matchValue[1].Case === \"SetOne\") {\r\n                var k2 = matchValue[1].Fields[0];\r\n                var t1_1 = matchValue[0];\r\n                return tree_add(comparer, k, tree_add(comparer, k2, t1_1));\r\n            }\r\n            else {\r\n                if (matchValue[1].Case === \"SetNode\") {\r\n                    var h1 = matchValue[0].Fields[3];\r\n                    var h2 = matchValue[1].Fields[3];\r\n                    var k1 = matchValue[0].Fields[0];\r\n                    var k2 = matchValue[1].Fields[0];\r\n                    var t11 = matchValue[0].Fields[1];\r\n                    var t12 = matchValue[0].Fields[2];\r\n                    var t21 = matchValue[1].Fields[1];\r\n                    var t22 = matchValue[1].Fields[2];\r\n                    if (h1 + tree_tolerance < h2) {\r\n                        return tree_rebalance(tree_balance(comparer, t1, k, t21), k2, t22);\r\n                    }\r\n                    else {\r\n                        if (h2 + tree_tolerance < h1) {\r\n                            return tree_rebalance(t11, k1, tree_balance(comparer, t12, k, t2));\r\n                        }\r\n                        else {\r\n                            return tree_mk(t1, k, t2);\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    return $target1(matchValue[0]);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            var t2_1 = matchValue[1];\r\n            return tree_add(comparer, k, t2_1);\r\n        }\r\n    }\r\n}\r\nfunction tree_split(comparer, pivot, t) {\r\n    if (t.Case === \"SetOne\") {\r\n        var c = comparer.Compare(t.Fields[0], pivot);\r\n        if (c < 0) {\r\n            return [t, false, new SetTree(\"SetEmpty\", [])];\r\n        }\r\n        else if (c === 0) {\r\n            return [new SetTree(\"SetEmpty\", []), true, new SetTree(\"SetEmpty\", [])];\r\n        }\r\n        else {\r\n            return [new SetTree(\"SetEmpty\", []), false, t];\r\n        }\r\n    }\r\n    else if (t.Case === \"SetEmpty\") {\r\n        return [new SetTree(\"SetEmpty\", []), false, new SetTree(\"SetEmpty\", [])];\r\n    }\r\n    else {\r\n        var c = comparer.Compare(pivot, t.Fields[0]);\r\n        if (c < 0) {\r\n            var patternInput = tree_split(comparer, pivot, t.Fields[1]);\r\n            return [patternInput[0], patternInput[1], tree_balance(comparer, patternInput[2], t.Fields[0], t.Fields[2])];\r\n        }\r\n        else if (c === 0) {\r\n            return [t.Fields[1], true, t.Fields[2]];\r\n        }\r\n        else {\r\n            var patternInput = tree_split(comparer, pivot, t.Fields[2]);\r\n            return [tree_balance(comparer, t.Fields[1], t.Fields[0], patternInput[0]), patternInput[1], patternInput[2]];\r\n        }\r\n    }\r\n}\r\nfunction tree_spliceOutSuccessor(t) {\r\n    if (t.Case === \"SetOne\") {\r\n        return [t.Fields[0], new SetTree(\"SetEmpty\", [])];\r\n    }\r\n    else if (t.Case === \"SetNode\") {\r\n        if (t.Fields[1].Case === \"SetEmpty\") {\r\n            return [t.Fields[0], t.Fields[2]];\r\n        }\r\n        else {\r\n            var patternInput = tree_spliceOutSuccessor(t.Fields[1]);\r\n            return [patternInput[0], tree_mk(patternInput[1], t.Fields[0], t.Fields[2])];\r\n        }\r\n    }\r\n    else {\r\n        throw new Error(\"internal error: Map.spliceOutSuccessor\");\r\n    }\r\n}\r\nfunction tree_remove(comparer, k, t) {\r\n    if (t.Case === \"SetOne\") {\r\n        var c = comparer.Compare(k, t.Fields[0]);\r\n        if (c === 0) {\r\n            return new SetTree(\"SetEmpty\", []);\r\n        }\r\n        else {\r\n            return t;\r\n        }\r\n    }\r\n    else if (t.Case === \"SetNode\") {\r\n        var c = comparer.Compare(k, t.Fields[0]);\r\n        if (c < 0) {\r\n            return tree_rebalance(tree_remove(comparer, k, t.Fields[1]), t.Fields[0], t.Fields[2]);\r\n        }\r\n        else if (c === 0) {\r\n            var matchValue = [t.Fields[1], t.Fields[2]];\r\n            if (matchValue[0].Case === \"SetEmpty\") {\r\n                return t.Fields[2];\r\n            }\r\n            else if (matchValue[1].Case === \"SetEmpty\") {\r\n                return t.Fields[1];\r\n            }\r\n            else {\r\n                var patternInput = tree_spliceOutSuccessor(t.Fields[2]);\r\n                return tree_mk(t.Fields[1], patternInput[0], patternInput[1]);\r\n            }\r\n        }\r\n        else {\r\n            return tree_rebalance(t.Fields[1], t.Fields[0], tree_remove(comparer, k, t.Fields[2]));\r\n        }\r\n    }\r\n    else {\r\n        return t;\r\n    }\r\n}\r\nfunction tree_mem(comparer, k, t) {\r\n    if (t.Case === \"SetOne\") {\r\n        return comparer.Compare(k, t.Fields[0]) === 0;\r\n    }\r\n    else if (t.Case === \"SetEmpty\") {\r\n        return false;\r\n    }\r\n    else {\r\n        var c = comparer.Compare(k, t.Fields[0]);\r\n        if (c < 0) {\r\n            return tree_mem(comparer, k, t.Fields[1]);\r\n        }\r\n        else if (c === 0) {\r\n            return true;\r\n        }\r\n        else {\r\n            return tree_mem(comparer, k, t.Fields[2]);\r\n        }\r\n    }\r\n}\r\nfunction tree_iter(f, t) {\r\n    if (t.Case === \"SetOne\") {\r\n        f(t.Fields[0]);\r\n    }\r\n    else {\r\n        if (t.Case === \"SetEmpty\") { }\r\n        else {\r\n            tree_iter(f, t.Fields[1]);\r\n            f(t.Fields[0]);\r\n            tree_iter(f, t.Fields[2]);\r\n        }\r\n    }\r\n}\r\nfunction tree_foldBack(f, m, x) {\r\n    return m.Case === \"SetOne\" ? f(m.Fields[0], x) : m.Case === \"SetEmpty\" ? x : tree_foldBack(f, m.Fields[1], f(m.Fields[0], tree_foldBack(f, m.Fields[2], x)));\r\n}\r\nfunction tree_fold(f, x, m) {\r\n    if (m.Case === \"SetOne\") {\r\n        return f(x, m.Fields[0]);\r\n    }\r\n    else if (m.Case === \"SetEmpty\") {\r\n        return x;\r\n    }\r\n    else {\r\n        var x_1 = tree_fold(f, x, m.Fields[1]);\r\n        var x_2 = f(x_1, m.Fields[0]);\r\n        return tree_fold(f, x_2, m.Fields[2]);\r\n    }\r\n}\r\nfunction tree_forall(f, m) {\r\n    return m.Case === \"SetOne\" ? f(m.Fields[0]) : m.Case === \"SetEmpty\" ? true : (f(m.Fields[0]) ? tree_forall(f, m.Fields[1]) : false) ? tree_forall(f, m.Fields[2]) : false;\r\n}\r\nfunction tree_exists(f, m) {\r\n    return m.Case === \"SetOne\" ? f(m.Fields[0]) : m.Case === \"SetEmpty\" ? false : (f(m.Fields[0]) ? true : tree_exists(f, m.Fields[1])) ? true : tree_exists(f, m.Fields[2]);\r\n}\r\nfunction tree_isEmpty(m) {\r\n    return m.Case === \"SetEmpty\" ? true : false;\r\n}\r\nfunction tree_subset(comparer, a, b) {\r\n    return tree_forall(function (x) { return tree_mem(comparer, x, b); }, a);\r\n}\r\nfunction tree_psubset(comparer, a, b) {\r\n    return tree_forall(function (x) { return tree_mem(comparer, x, b); }, a) ? tree_exists(function (x) { return !tree_mem(comparer, x, a); }, b) : false;\r\n}\r\nfunction tree_filterAux(comparer, f, s, acc) {\r\n    if (s.Case === \"SetOne\") {\r\n        if (f(s.Fields[0])) {\r\n            return tree_add(comparer, s.Fields[0], acc);\r\n        }\r\n        else {\r\n            return acc;\r\n        }\r\n    }\r\n    else if (s.Case === \"SetEmpty\") {\r\n        return acc;\r\n    }\r\n    else {\r\n        var acc_1 = f(s.Fields[0]) ? tree_add(comparer, s.Fields[0], acc) : acc;\r\n        return tree_filterAux(comparer, f, s.Fields[1], tree_filterAux(comparer, f, s.Fields[2], acc_1));\r\n    }\r\n}\r\nfunction tree_filter(comparer, f, s) {\r\n    return tree_filterAux(comparer, f, s, new SetTree(\"SetEmpty\", []));\r\n}\r\nfunction tree_diffAux(comparer, m, acc) {\r\n    return m.Case === \"SetOne\" ? tree_remove(comparer, m.Fields[0], acc) : m.Case === \"SetEmpty\" ? acc : tree_diffAux(comparer, m.Fields[1], tree_diffAux(comparer, m.Fields[2], tree_remove(comparer, m.Fields[0], acc)));\r\n}\r\nfunction tree_diff(comparer, a, b) {\r\n    return tree_diffAux(comparer, b, a);\r\n}\r\nfunction tree_union(comparer, t1, t2) {\r\n    var matchValue = [t1, t2];\r\n    var $target2 = function (t) { return t; };\r\n    var $target3 = function (k1, t2_1) { return tree_add(comparer, k1, t2_1); };\r\n    if (matchValue[0].Case === \"SetEmpty\") {\r\n        var t = matchValue[1];\r\n        return t;\r\n    }\r\n    else {\r\n        if (matchValue[0].Case === \"SetOne\") {\r\n            if (matchValue[1].Case === \"SetEmpty\") {\r\n                return $target2(matchValue[0]);\r\n            }\r\n            else {\r\n                if (matchValue[1].Case === \"SetOne\") {\r\n                    return $target3(matchValue[0].Fields[0], matchValue[1]);\r\n                }\r\n                else {\r\n                    return $target3(matchValue[0].Fields[0], matchValue[1]);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            if (matchValue[1].Case === \"SetEmpty\") {\r\n                return $target2(matchValue[0]);\r\n            }\r\n            else {\r\n                if (matchValue[1].Case === \"SetOne\") {\r\n                    var k2 = matchValue[1].Fields[0];\r\n                    var t1_1 = matchValue[0];\r\n                    return tree_add(comparer, k2, t1_1);\r\n                }\r\n                else {\r\n                    var h1 = matchValue[0].Fields[3];\r\n                    var h2 = matchValue[1].Fields[3];\r\n                    var k1 = matchValue[0].Fields[0];\r\n                    var k2 = matchValue[1].Fields[0];\r\n                    var t11 = matchValue[0].Fields[1];\r\n                    var t12 = matchValue[0].Fields[2];\r\n                    var t21 = matchValue[1].Fields[1];\r\n                    var t22 = matchValue[1].Fields[2];\r\n                    if (h1 > h2) {\r\n                        var patternInput = tree_split(comparer, k1, t2);\r\n                        var lo = patternInput[0];\r\n                        var hi = patternInput[2];\r\n                        return tree_balance(comparer, tree_union(comparer, t11, lo), k1, tree_union(comparer, t12, hi));\r\n                    }\r\n                    else {\r\n                        var patternInput = tree_split(comparer, k2, t1);\r\n                        var lo = patternInput[0];\r\n                        var hi = patternInput[2];\r\n                        return tree_balance(comparer, tree_union(comparer, t21, lo), k2, tree_union(comparer, t22, hi));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction tree_intersectionAux(comparer, b, m, acc) {\r\n    if (m.Case === \"SetOne\") {\r\n        if (tree_mem(comparer, m.Fields[0], b)) {\r\n            return tree_add(comparer, m.Fields[0], acc);\r\n        }\r\n        else {\r\n            return acc;\r\n        }\r\n    }\r\n    else if (m.Case === \"SetEmpty\") {\r\n        return acc;\r\n    }\r\n    else {\r\n        var acc_1 = tree_intersectionAux(comparer, b, m.Fields[2], acc);\r\n        var acc_2 = tree_mem(comparer, m.Fields[0], b) ? tree_add(comparer, m.Fields[0], acc_1) : acc_1;\r\n        return tree_intersectionAux(comparer, b, m.Fields[1], acc_2);\r\n    }\r\n}\r\nfunction tree_intersection(comparer, a, b) {\r\n    return tree_intersectionAux(comparer, b, a, new SetTree(\"SetEmpty\", []));\r\n}\r\nfunction tree_partition1(comparer, f, k, acc1, acc2) {\r\n    return f(k) ? [tree_add(comparer, k, acc1), acc2] : [acc1, tree_add(comparer, k, acc2)];\r\n}\r\nfunction tree_partitionAux(comparer, f, s, acc_0, acc_1) {\r\n    var acc = [acc_0, acc_1];\r\n    if (s.Case === \"SetOne\") {\r\n        var acc1 = acc[0];\r\n        var acc2 = acc[1];\r\n        return tree_partition1(comparer, f, s.Fields[0], acc1, acc2);\r\n    }\r\n    else {\r\n        if (s.Case === \"SetEmpty\") {\r\n            return acc;\r\n        }\r\n        else {\r\n            var acc_2 = tree_partitionAux(comparer, f, s.Fields[2], acc[0], acc[1]);\r\n            var acc_3 = tree_partition1(comparer, f, s.Fields[0], acc_2[0], acc_2[1]);\r\n            return tree_partitionAux(comparer, f, s.Fields[1], acc_3[0], acc_3[1]);\r\n        }\r\n    }\r\n}\r\nfunction tree_partition(comparer, f, s) {\r\n    var seed = [new SetTree(\"SetEmpty\", []), new SetTree(\"SetEmpty\", [])];\r\n    var arg30_ = seed[0];\r\n    var arg31_ = seed[1];\r\n    return tree_partitionAux(comparer, f, s, arg30_, arg31_);\r\n}\r\nfunction tree_minimumElementAux(s, n) {\r\n    return s.Case === \"SetOne\" ? s.Fields[0] : s.Case === \"SetEmpty\" ? n : tree_minimumElementAux(s.Fields[1], s.Fields[0]);\r\n}\r\nfunction tree_minimumElementOpt(s) {\r\n    return s.Case === \"SetOne\" ? s.Fields[0] : s.Case === \"SetEmpty\" ? null : tree_minimumElementAux(s.Fields[1], s.Fields[0]);\r\n}\r\nfunction tree_maximumElementAux(s, n) {\r\n    return s.Case === \"SetOne\" ? s.Fields[0] : s.Case === \"SetEmpty\" ? n : tree_maximumElementAux(s.Fields[2], s.Fields[0]);\r\n}\r\nfunction tree_maximumElementOpt(s) {\r\n    return s.Case === \"SetOne\" ? s.Fields[0] : s.Case === \"SetEmpty\" ? null : tree_maximumElementAux(s.Fields[2], s.Fields[0]);\r\n}\r\nfunction tree_minimumElement(s) {\r\n    var matchValue = tree_minimumElementOpt(s);\r\n    if (matchValue == null) {\r\n        throw new Error(\"Set contains no elements\");\r\n    }\r\n    else {\r\n        return matchValue;\r\n    }\r\n}\r\nfunction tree_maximumElement(s) {\r\n    var matchValue = tree_maximumElementOpt(s);\r\n    if (matchValue == null) {\r\n        throw new Error(\"Set contains no elements\");\r\n    }\r\n    else {\r\n        return matchValue;\r\n    }\r\n}\r\nfunction tree_collapseLHS(stack) {\r\n    return stack.tail != null\r\n        ? stack.head.Case === \"SetOne\"\r\n            ? stack\r\n            : stack.head.Case === \"SetNode\"\r\n                ? tree_collapseLHS(listOfArray([\r\n                    stack.head.Fields[1],\r\n                    tree_SetOne(stack.head.Fields[0]),\r\n                    stack.head.Fields[2]\r\n                ], stack.tail))\r\n                : tree_collapseLHS(stack.tail)\r\n        : new List();\r\n}\r\nfunction tree_mkIterator(s) {\r\n    return { stack: tree_collapseLHS(new List(s, new List())), started: false };\r\n}\r\n;\r\nfunction tree_moveNext(i) {\r\n    function current(i) {\r\n        if (i.stack.tail == null) {\r\n            return null;\r\n        }\r\n        else if (i.stack.head.Case === \"SetOne\") {\r\n            return i.stack.head.Fields[0];\r\n        }\r\n        throw new Error(\"Please report error: Set iterator, unexpected stack for current\");\r\n    }\r\n    if (i.started) {\r\n        if (i.stack.tail == null) {\r\n            return { done: true, value: null };\r\n        }\r\n        else {\r\n            if (i.stack.head.Case === \"SetOne\") {\r\n                i.stack = tree_collapseLHS(i.stack.tail);\r\n                return {\r\n                    done: i.stack.tail == null,\r\n                    value: current(i)\r\n                };\r\n            }\r\n            else {\r\n                throw new Error(\"Please report error: Set iterator, unexpected stack for moveNext\");\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        i.started = true;\r\n        return {\r\n            done: i.stack.tail == null,\r\n            value: current(i)\r\n        };\r\n    }\r\n    ;\r\n}\r\nfunction tree_compareStacks(comparer, l1, l2) {\r\n    var $target8 = function (n1k, t1) { return tree_compareStacks(comparer, listOfArray([new SetTree(\"SetEmpty\", []), tree_SetOne(n1k)], t1), l2); };\r\n    var $target9 = function (n1k, n1l, n1r, t1) { return tree_compareStacks(comparer, listOfArray([n1l, tree_SetNode(n1k, new SetTree(\"SetEmpty\", []), n1r, 0)], t1), l2); };\r\n    var $target11 = function (n2k, n2l, n2r, t2) { return tree_compareStacks(comparer, l1, listOfArray([n2l, tree_SetNode(n2k, new SetTree(\"SetEmpty\", []), n2r, 0)], t2)); };\r\n    if (l1.tail != null) {\r\n        if (l2.tail != null) {\r\n            if (l2.head.Case === \"SetOne\") {\r\n                if (l1.head.Case === \"SetOne\") {\r\n                    var n1k = l1.head.Fields[0], n2k = l2.head.Fields[0], t1 = l1.tail, t2 = l2.tail, c = comparer.Compare(n1k, n2k);\r\n                    if (c !== 0) {\r\n                        return c;\r\n                    }\r\n                    else {\r\n                        return tree_compareStacks(comparer, t1, t2);\r\n                    }\r\n                }\r\n                else {\r\n                    if (l1.head.Case === \"SetNode\") {\r\n                        if (l1.head.Fields[1].Case === \"SetEmpty\") {\r\n                            var emp = l1.head.Fields[1], n1k = l1.head.Fields[0], n1r = l1.head.Fields[2], n2k = l2.head.Fields[0], t1 = l1.tail, t2 = l2.tail, c = comparer.Compare(n1k, n2k);\r\n                            if (c !== 0) {\r\n                                return c;\r\n                            }\r\n                            else {\r\n                                return tree_compareStacks(comparer, listOfArray([n1r], t1), listOfArray([emp], t2));\r\n                            }\r\n                        }\r\n                        else {\r\n                            return $target9(l1.head.Fields[0], l1.head.Fields[1], l1.head.Fields[2], l1.tail);\r\n                        }\r\n                    }\r\n                    else {\r\n                        var n2k = l2.head.Fields[0], t2 = l2.tail;\r\n                        return tree_compareStacks(comparer, l1, listOfArray([new SetTree(\"SetEmpty\", []), tree_SetOne(n2k)], t2));\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                if (l2.head.Case === \"SetNode\") {\r\n                    if (l2.head.Fields[1].Case === \"SetEmpty\") {\r\n                        if (l1.head.Case === \"SetOne\") {\r\n                            var n1k = l1.head.Fields[0], n2k = l2.head.Fields[0], n2r = l2.head.Fields[2], t1 = l1.tail, t2 = l2.tail, c = comparer.Compare(n1k, n2k);\r\n                            if (c !== 0) {\r\n                                return c;\r\n                            }\r\n                            else {\r\n                                return tree_compareStacks(comparer, listOfArray([new SetTree(\"SetEmpty\", [])], t1), listOfArray([n2r], t2));\r\n                            }\r\n                        }\r\n                        else {\r\n                            if (l1.head.Case === \"SetNode\") {\r\n                                if (l1.head.Fields[1].Case === \"SetEmpty\") {\r\n                                    var n1k = l1.head.Fields[0], n1r = l1.head.Fields[2], n2k = l2.head.Fields[0], n2r = l2.head.Fields[2], t1 = l1.tail, t2 = l2.tail, c = comparer.Compare(n1k, n2k);\r\n                                    if (c !== 0) {\r\n                                        return c;\r\n                                    }\r\n                                    else {\r\n                                        return tree_compareStacks(comparer, listOfArray([n1r], t1), listOfArray([n2r], t2));\r\n                                    }\r\n                                }\r\n                                else {\r\n                                    return $target9(l1.head.Fields[0], l1.head.Fields[1], l1.head.Fields[2], l1.tail);\r\n                                }\r\n                            }\r\n                            else {\r\n                                return $target11(l2.head.Fields[0], l2.head.Fields[1], l2.head.Fields[2], l2.tail);\r\n                            }\r\n                        }\r\n                    }\r\n                    else {\r\n                        if (l1.head.Case === \"SetOne\") {\r\n                            return $target8(l1.head.Fields[0], l1.tail);\r\n                        }\r\n                        else {\r\n                            if (l1.head.Case === \"SetNode\") {\r\n                                return $target9(l1.head.Fields[0], l1.head.Fields[1], l1.head.Fields[2], l1.tail);\r\n                            }\r\n                            else {\r\n                                return $target11(l2.head.Fields[0], l2.head.Fields[1], l2.head.Fields[2], l2.tail);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    if (l1.head.Case === \"SetOne\") {\r\n                        return $target8(l1.head.Fields[0], l1.tail);\r\n                    }\r\n                    else {\r\n                        if (l1.head.Case === \"SetNode\") {\r\n                            return $target9(l1.head.Fields[0], l1.head.Fields[1], l1.head.Fields[2], l1.tail);\r\n                        }\r\n                        else {\r\n                            return tree_compareStacks(comparer, l1.tail, l2.tail);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            return 1;\r\n        }\r\n    }\r\n    else {\r\n        if (l2.tail != null) {\r\n            return -1;\r\n        }\r\n        else {\r\n            return 0;\r\n        }\r\n    }\r\n}\r\nfunction tree_compare(comparer, s1, s2) {\r\n    if (s1.Case === \"SetEmpty\") {\r\n        if (s2.Case === \"SetEmpty\") {\r\n            return 0;\r\n        }\r\n        else {\r\n            return -1;\r\n        }\r\n    }\r\n    else {\r\n        if (s2.Case === \"SetEmpty\") {\r\n            return 1;\r\n        }\r\n        else {\r\n            return tree_compareStacks(comparer, listOfArray([s1]), listOfArray([s2]));\r\n        }\r\n    }\r\n}\r\nfunction tree_mkFromEnumerator(comparer, acc, e) {\r\n    var cur = e.next();\r\n    while (!cur.done) {\r\n        acc = tree_add(comparer, cur.value, acc);\r\n        cur = e.next();\r\n    }\r\n    return acc;\r\n}\r\nfunction tree_ofSeq(comparer, c) {\r\n    var ie = c[Symbol.iterator]();\r\n    return tree_mkFromEnumerator(comparer, new SetTree(\"SetEmpty\", []), ie);\r\n}\r\nvar FableSet = (function () {\r\n    function FableSet() {\r\n    }\r\n    FableSet.prototype.ToString = function () {\r\n        return \"set [\" + Array.from(this).map(toString).join(\"; \") + \"]\";\r\n    };\r\n    FableSet.prototype.Equals = function (s2) {\r\n        return this.CompareTo(s2) === 0;\r\n    };\r\n    FableSet.prototype.CompareTo = function (s2) {\r\n        return this === s2 ? 0 : tree_compare(this.comparer, this.tree, s2.tree);\r\n    };\r\n    FableSet.prototype[Symbol.iterator] = function () {\r\n        var i = tree_mkIterator(this.tree);\r\n        return {\r\n            next: function () { return tree_moveNext(i); }\r\n        };\r\n    };\r\n    FableSet.prototype.values = function () {\r\n        return this[Symbol.iterator]();\r\n    };\r\n    FableSet.prototype.has = function (v) {\r\n        return tree_mem(this.comparer, v, this.tree);\r\n    };\r\n    FableSet.prototype.add = function (v) {\r\n        throw new Error(\"not supported\");\r\n    };\r\n    FableSet.prototype.delete = function (v) {\r\n        throw new Error(\"not supported\");\r\n    };\r\n    FableSet.prototype.clear = function () {\r\n        throw new Error(\"not supported\");\r\n    };\r\n    Object.defineProperty(FableSet.prototype, \"size\", {\r\n        get: function () {\r\n            return tree_count(this.tree);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    FableSet.prototype[FSymbol.reflection] = function () {\r\n        return {\r\n            type: \"Microsoft.FSharp.Collections.FSharpSet\",\r\n            interfaces: [\"System.IEquatable\", \"System.IComparable\"]\r\n        };\r\n    };\r\n    return FableSet;\r\n}());\r\nexport default FableSet;\r\nfunction from(comparer, tree) {\r\n    var s = new FableSet();\r\n    s.tree = tree;\r\n    s.comparer = comparer || new GenericComparer();\r\n    return s;\r\n}\r\nexport function create(ie, comparer) {\r\n    comparer = comparer || new GenericComparer();\r\n    return from(comparer, ie ? tree_ofSeq(comparer, ie) : new SetTree(\"SetEmpty\", []));\r\n}\r\nexport function isEmpty(s) {\r\n    return tree_isEmpty(s.tree);\r\n}\r\nexport function add(item, s) {\r\n    return from(s.comparer, tree_add(s.comparer, item, s.tree));\r\n}\r\nexport function addInPlace(item, s) {\r\n    return s.has(item) ? false : (s.add(item), true);\r\n}\r\nexport function remove(item, s) {\r\n    return from(s.comparer, tree_remove(s.comparer, item, s.tree));\r\n}\r\nexport function union(set1, set2) {\r\n    return set2.tree.Case === \"SetEmpty\"\r\n        ? set1\r\n        : set1.tree.Case === \"SetEmpty\"\r\n            ? set2\r\n            : from(set1.comparer, tree_union(set1.comparer, set1.tree, set2.tree));\r\n}\r\nexport function op_Addition(set1, set2) {\r\n    return union(set1, set2);\r\n}\r\nexport function unionInPlace(set1, set2) {\r\n    seqIterate(function (x) { set1.add(x); }, set2);\r\n}\r\nexport function unionMany(sets) {\r\n    return seqFold(function (acc, s) { return union(s, acc); }, create(), sets);\r\n}\r\nexport function difference(set1, set2) {\r\n    return set1.tree.Case === \"SetEmpty\"\r\n        ? set1\r\n        : set2.tree.Case === \"SetEmpty\"\r\n            ? set1\r\n            : from(set1.comparer, tree_diff(set1.comparer, set1.tree, set2.tree));\r\n}\r\nexport function op_Subtraction(set1, set2) {\r\n    return difference(set1, set2);\r\n}\r\nexport function differenceInPlace(set1, set2) {\r\n    seqIterate(function (x) { set1.delete(x); }, set2);\r\n}\r\nexport function intersect(set1, set2) {\r\n    return set2.tree.Case === \"SetEmpty\"\r\n        ? set2\r\n        : set1.tree.Case === \"SetEmpty\"\r\n            ? set1\r\n            : from(set1.comparer, tree_intersection(set1.comparer, set1.tree, set2.tree));\r\n}\r\nexport function intersectInPlace(set1, set2) {\r\n    var set2_ = set2 instanceof Set ? set2 : new Set(set2);\r\n    seqIterate(function (x) { if (!set2_.has(x)) {\r\n        set1.delete(x);\r\n    } }, set1);\r\n}\r\nexport function intersectMany(sets) {\r\n    return seqReduce(function (s1, s2) { return intersect(s1, s2); }, sets);\r\n}\r\nexport function isProperSubsetOf(set1, set2) {\r\n    if (set1 instanceof FableSet && set2 instanceof FableSet) {\r\n        return tree_psubset(set1.comparer, set1.tree, set2.tree);\r\n    }\r\n    else {\r\n        set2 = set2 instanceof Set ? set2 : new Set(set2);\r\n        return seqForAll(function (x) { return set2.has(x); }, set1) && seqExists(function (x) { return !set1.has(x); }, set2);\r\n    }\r\n}\r\nexport function isProperSubset(set1, set2) {\r\n    return isProperSubsetOf(set1, set2);\r\n}\r\nexport function isSubsetOf(set1, set2) {\r\n    if (set1 instanceof FableSet && set2 instanceof FableSet) {\r\n        return tree_subset(set1.comparer, set1.tree, set2.tree);\r\n    }\r\n    else {\r\n        set2 = set2 instanceof Set ? set2 : new Set(set2);\r\n        return seqForAll(function (x) { return set2.has(x); }, set1);\r\n    }\r\n}\r\nexport function isSubset(set1, set2) {\r\n    return isSubsetOf(set1, set2);\r\n}\r\nexport function isProperSupersetOf(set1, set2) {\r\n    if (set1 instanceof FableSet && set2 instanceof FableSet) {\r\n        return tree_psubset(set1.comparer, set2.tree, set1.tree);\r\n    }\r\n    else {\r\n        return isProperSubset(set2 instanceof Set ? set2 : new Set(set2), set1);\r\n    }\r\n}\r\nexport function isProperSuperset(set1, set2) {\r\n    return isProperSupersetOf(set1, set2);\r\n}\r\nexport function isSupersetOf(set1, set2) {\r\n    if (set1 instanceof FableSet && set2 instanceof FableSet) {\r\n        return tree_subset(set1.comparer, set2.tree, set1.tree);\r\n    }\r\n    else {\r\n        return isSubset(set2 instanceof Set ? set2 : new Set(set2), set1);\r\n    }\r\n}\r\nexport function isSuperset(set1, set2) {\r\n    return isSupersetOf(set1, set2);\r\n}\r\nexport function copyTo(xs, arr, arrayIndex, count) {\r\n    if (!Array.isArray(arr) && !ArrayBuffer.isView(arr))\r\n        throw new Error(\"Array is invalid\");\r\n    count = count || arr.length;\r\n    var i = arrayIndex || 0;\r\n    var iter = xs[Symbol.iterator]();\r\n    while (count--) {\r\n        var el = iter.next();\r\n        if (el.done)\r\n            break;\r\n        arr[i++] = el.value;\r\n    }\r\n}\r\nexport function partition(f, s) {\r\n    if (s.tree.Case === \"SetEmpty\") {\r\n        return [s, s];\r\n    }\r\n    else {\r\n        var tuple = tree_partition(s.comparer, f, s.tree);\r\n        return [from(s.comparer, tuple[0]), from(s.comparer, tuple[1])];\r\n    }\r\n}\r\nexport function filter(f, s) {\r\n    if (s.tree.Case === \"SetEmpty\") {\r\n        return s;\r\n    }\r\n    else {\r\n        return from(s.comparer, tree_filter(s.comparer, f, s.tree));\r\n    }\r\n}\r\nexport function map(f, s) {\r\n    var comparer = new GenericComparer();\r\n    return from(comparer, tree_fold(function (acc, k) { return tree_add(comparer, f(k), acc); }, new SetTree(\"SetEmpty\", []), s.tree));\r\n}\r\nexport function exists(f, s) {\r\n    return tree_exists(f, s.tree);\r\n}\r\nexport function forAll(f, s) {\r\n    return tree_forall(f, s.tree);\r\n}\r\nexport function fold(f, seed, s) {\r\n    return tree_fold(f, seed, s.tree);\r\n}\r\nexport function foldBack(f, s, seed) {\r\n    return tree_foldBack(f, s.tree, seed);\r\n}\r\nexport function iterate(f, s) {\r\n    tree_iter(f, s.tree);\r\n}\r\nexport function minimumElement(s) {\r\n    return tree_minimumElement(s.tree);\r\n}\r\nexport function minElement(s) {\r\n    return tree_minimumElement(s.tree);\r\n}\r\nexport function maximumElement(s) {\r\n    return tree_maximumElement(s.tree);\r\n}\r\nexport function maxElement(s) {\r\n    return tree_maximumElement(s.tree);\r\n}\r\n","import { NonDeclaredType, getPropertyNames, getDefinition } from \"./Util\";\r\nimport List from \"./List\";\r\nimport FSymbol from \"./Symbol\";\r\nvar MemberInfo = (function () {\r\n    function MemberInfo(name, index, declaringType, propertyType, unionFields) {\r\n        this.name = name;\r\n        this.index = index;\r\n        this.declaringType = declaringType;\r\n        this.propertyType = propertyType;\r\n        this.unionFields = unionFields;\r\n    }\r\n    MemberInfo.prototype.getUnionFields = function () {\r\n        var _this = this;\r\n        return this.unionFields.map(function (fi, i) { return new MemberInfo(\"unknown\", i, _this.declaringType, fi); });\r\n    };\r\n    return MemberInfo;\r\n}());\r\nexport { MemberInfo };\r\nexport function resolveGeneric(idx, enclosing) {\r\n    try {\r\n        var t = enclosing.head;\r\n        if (t.generics == null) {\r\n            return resolveGeneric(idx, enclosing.tail);\r\n        }\r\n        else {\r\n            var name_1 = typeof idx === \"string\"\r\n                ? idx : Object.getOwnPropertyNames(t.generics)[idx];\r\n            var resolved = t.generics[name_1];\r\n            if (resolved == null) {\r\n                return resolveGeneric(idx, enclosing.tail);\r\n            }\r\n            else if (resolved instanceof NonDeclaredType && resolved.kind === \"GenericParam\") {\r\n                return resolveGeneric(resolved.definition, enclosing.tail);\r\n            }\r\n            else {\r\n                return new List(resolved, enclosing);\r\n            }\r\n        }\r\n    }\r\n    catch (err) {\r\n        throw new Error(\"Cannot resolve generic argument \" + idx + \": \" + err);\r\n    }\r\n}\r\nexport function getType(obj) {\r\n    var t = typeof obj;\r\n    switch (t) {\r\n        case \"boolean\":\r\n        case \"number\":\r\n        case \"string\":\r\n        case \"function\":\r\n            return t;\r\n        default:\r\n            return Object.getPrototypeOf(obj).constructor;\r\n    }\r\n}\r\nexport function getTypeFullName(typ, option) {\r\n    function trim(fullName, option) {\r\n        if (typeof fullName !== \"string\") {\r\n            return \"unknown\";\r\n        }\r\n        if (option === \"name\") {\r\n            var i = fullName.lastIndexOf('.');\r\n            return fullName.substr(i + 1);\r\n        }\r\n        if (option === \"namespace\") {\r\n            var i = fullName.lastIndexOf('.');\r\n            return i > -1 ? fullName.substr(0, i) : \"\";\r\n        }\r\n        return fullName;\r\n    }\r\n    if (typeof typ === \"string\") {\r\n        return typ;\r\n    }\r\n    else if (typ instanceof NonDeclaredType) {\r\n        switch (typ.kind) {\r\n            case \"Unit\":\r\n                return \"unit\";\r\n            case \"Option\":\r\n                return getTypeFullName(typ.generics, option) + \" option\";\r\n            case \"Array\":\r\n                return getTypeFullName(typ.generics, option) + \"[]\";\r\n            case \"Tuple\":\r\n                return typ.generics.map(function (x) { return getTypeFullName(x, option); }).join(\" * \");\r\n            case \"GenericParam\":\r\n            case \"Interface\":\r\n                return typ.definition;\r\n            case \"GenericType\":\r\n                return getTypeFullName(typ.definition, option);\r\n            case \"Any\":\r\n            default:\r\n                return \"unknown\";\r\n        }\r\n    }\r\n    else {\r\n        var proto = typ.prototype;\r\n        return trim(typeof proto[FSymbol.reflection] === \"function\"\r\n            ? proto[FSymbol.reflection]().type : null, option);\r\n    }\r\n}\r\nexport function getName(x) {\r\n    if (x instanceof MemberInfo) {\r\n        return x.name;\r\n    }\r\n    return getTypeFullName(x, \"name\");\r\n}\r\nexport function getPrototypeOfType(typ) {\r\n    if (typeof typ === \"string\") {\r\n        return null;\r\n    }\r\n    else if (typ instanceof NonDeclaredType) {\r\n        return typ.kind === \"GenericType\" ? typ.definition.prototype : null;\r\n    }\r\n    else {\r\n        return typ.prototype;\r\n    }\r\n}\r\nexport function getProperties(typ) {\r\n    var proto = getPrototypeOfType(typ);\r\n    if (proto != null && typeof proto[FSymbol.reflection] === \"function\") {\r\n        var info_1 = proto[FSymbol.reflection]();\r\n        if (info_1.properties) {\r\n            return Object.getOwnPropertyNames(info_1.properties)\r\n                .map(function (k, i) { return new MemberInfo(k, i, typ, info_1.properties[k]); });\r\n        }\r\n    }\r\n    throw new Error(\"Type \" + getTypeFullName(typ) + \" doesn't contain property info.\");\r\n}\r\nexport function getUnionCases(typ) {\r\n    var proto = getPrototypeOfType(typ);\r\n    if (proto != null && typeof proto[FSymbol.reflection] === \"function\") {\r\n        var info_2 = proto[FSymbol.reflection]();\r\n        if (info_2.cases) {\r\n            return Object.getOwnPropertyNames(info_2.cases)\r\n                .map(function (k, i) { return new MemberInfo(k, i, typ, null, info_2.cases[k]); });\r\n        }\r\n    }\r\n    throw new Error(\"Type \" + getTypeFullName(typ) + \" doesn't contain union case info.\");\r\n}\r\nexport function getPropertyValues(obj) {\r\n    return getPropertyNames(obj).map(function (k) { return obj[k]; });\r\n}\r\nexport function getUnionFields(obj, typ) {\r\n    if (obj != null && typeof obj[FSymbol.reflection] === \"function\") {\r\n        var info = obj[FSymbol.reflection]();\r\n        if (info.cases) {\r\n            var uci = null, cases = Object.getOwnPropertyNames(info.cases);\r\n            for (var i = 0; i < cases.length; i++) {\r\n                if (cases[i] === obj.Case) {\r\n                    uci = new MemberInfo(cases[i], i, typ, null, info.cases[cases[i]]);\r\n                    break;\r\n                }\r\n            }\r\n            if (uci != null) {\r\n                return [uci, obj.Fields];\r\n            }\r\n        }\r\n    }\r\n    throw new Error(\"Not an F# union type.\");\r\n}\r\nexport function makeUnion(caseInfo, args) {\r\n    var Cons = getDefinition(caseInfo.declaringType);\r\n    return new (Cons.bind.apply(Cons, [void 0, caseInfo.name].concat(args)))();\r\n}\r\nexport function getTupleElements(typ) {\r\n    if (typ instanceof NonDeclaredType && typ.kind === \"Tuple\") {\r\n        return typ.generics;\r\n    }\r\n    throw new Error(\"Type \" + getTypeFullName(typ) + \" is not a tuple type.\");\r\n}\r\nexport function isTupleType(typ) {\r\n    if (typ instanceof NonDeclaredType) {\r\n        return typ.kind === \"Tuple\";\r\n    }\r\n    return false;\r\n}\r\n","import FableSymbol from \"./Symbol\";\r\nimport { getType } from \"./Symbol\";\r\nimport List from \"./List\";\r\nimport { ofArray as listOfArray } from \"./List\";\r\nimport FableSet from \"./Set\";\r\nimport FableMap from \"./Map\";\r\nimport { create as mapCreate } from \"./Map\";\r\nimport { create as setCreate } from \"./Set\";\r\nimport { hasInterface } from \"./Util\";\r\nimport { getDefinition } from \"./Util\";\r\nimport { NonDeclaredType } from \"./Util\";\r\nimport { fold } from \"./Seq\";\r\nimport { resolveGeneric, getTypeFullName } from \"./Reflection\";\r\nimport { parse as dateParse } from \"./Date\";\r\nimport { fsFormat } from \"./String\";\r\nexport function toJson(o) {\r\n    return JSON.stringify(o, function (k, v) {\r\n        if (ArrayBuffer.isView(v)) {\r\n            return Array.from(v);\r\n        }\r\n        else if (v != null && typeof v === \"object\") {\r\n            var properties = typeof v[FableSymbol.reflection] === \"function\" ? v[FableSymbol.reflection]().properties : null;\r\n            if (v instanceof List || v instanceof FableSet || v instanceof Set) {\r\n                return Array.from(v);\r\n            }\r\n            else if (v instanceof FableMap || v instanceof Map) {\r\n                var stringKeys_1 = null;\r\n                return fold(function (o, kv) {\r\n                    if (stringKeys_1 === null) {\r\n                        stringKeys_1 = typeof kv[0] === \"string\";\r\n                    }\r\n                    o[stringKeys_1 ? kv[0] : toJson(kv[0])] = kv[1];\r\n                    return o;\r\n                }, {}, v);\r\n            }\r\n            else if (!hasInterface(v, \"FSharpRecord\") && properties) {\r\n                return fold(function (o, prop) {\r\n                    return o[prop] = v[prop], o;\r\n                }, {}, Object.getOwnPropertyNames(properties));\r\n            }\r\n            else if (hasInterface(v, \"FSharpUnion\")) {\r\n                if (!v.Fields || !v.Fields.length) {\r\n                    return v.Case;\r\n                }\r\n                else if (v.Fields.length === 1) {\r\n                    var fieldValue = typeof v.Fields[0] === 'undefined' ? null : v.Fields[0];\r\n                    return _a = {}, _a[v.Case] = fieldValue, _a;\r\n                }\r\n                else {\r\n                    return _b = {}, _b[v.Case] = v.Fields, _b;\r\n                }\r\n            }\r\n        }\r\n        return v;\r\n        var _a, _b;\r\n    });\r\n}\r\nfunction combine(path1, path2) {\r\n    return typeof path2 === \"number\"\r\n        ? path1 + \"[\" + path2 + \"]\"\r\n        : (path1 ? path1 + \".\" : \"\") + path2;\r\n}\r\nfunction isNullable(typ) {\r\n    if (typeof typ === \"string\") {\r\n        return typ !== \"boolean\" && typ !== \"number\";\r\n    }\r\n    else if (typ instanceof NonDeclaredType) {\r\n        return typ.kind !== \"Array\" && typ.kind !== \"Tuple\";\r\n    }\r\n    else {\r\n        var info = typeof typ.prototype[FableSymbol.reflection] === \"function\"\r\n            ? typ.prototype[FableSymbol.reflection]() : null;\r\n        return info ? info.nullable : true;\r\n    }\r\n}\r\nfunction invalidate(val, typ, path) {\r\n    throw new Error(fsFormat(\"%A\", val) + \" \" + (path ? \"(\" + path + \")\" : \"\") + \" is not of type \" + getTypeFullName(typ));\r\n}\r\nfunction needsInflate(enclosing) {\r\n    var typ = enclosing.head;\r\n    if (typeof typ === \"string\") {\r\n        return false;\r\n    }\r\n    if (typ instanceof NonDeclaredType) {\r\n        switch (typ.kind) {\r\n            case \"Option\":\r\n            case \"Array\":\r\n                return typ.definition != null || needsInflate(new List(typ.generics, enclosing));\r\n            case \"Tuple\":\r\n                return typ.generics.some(function (x) {\r\n                    return needsInflate(new List(x, enclosing));\r\n                });\r\n            case \"GenericParam\":\r\n                return needsInflate(resolveGeneric(typ.definition, enclosing.tail));\r\n            case \"GenericType\":\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nfunction inflateArray(arr, enclosing, path) {\r\n    if (!Array.isArray) {\r\n        invalidate(arr, \"array\", path);\r\n    }\r\n    return needsInflate(enclosing)\r\n        ? arr.map(function (x, i) { return inflate(x, enclosing, combine(path, i)); })\r\n        : arr;\r\n}\r\nfunction inflateMap(obj, keyEnclosing, valEnclosing, path) {\r\n    var inflateKey = keyEnclosing.head !== \"string\";\r\n    var inflateVal = needsInflate(valEnclosing);\r\n    return Object\r\n        .getOwnPropertyNames(obj)\r\n        .map(function (k) {\r\n        var key = inflateKey ? inflate(JSON.parse(k), keyEnclosing, combine(path, k)) : k;\r\n        var val = inflateVal ? inflate(obj[k], valEnclosing, combine(path, k)) : obj[k];\r\n        return [key, val];\r\n    });\r\n}\r\nfunction inflateList(val, enclosing, path) {\r\n    var ar = [], li = new List(), cur = val, inf = needsInflate(enclosing);\r\n    while (cur.tail != null) {\r\n        ar.push(inf ? inflate(cur.head, enclosing, path) : cur.head);\r\n        cur = cur.tail;\r\n    }\r\n    ar.reverse();\r\n    for (var i = 0; i < ar.length; i++) {\r\n        li = new List(ar[i], li);\r\n    }\r\n    return li;\r\n}\r\nfunction inflate(val, typ, path) {\r\n    var enclosing = null;\r\n    if (typ instanceof List) {\r\n        enclosing = typ;\r\n        typ = typ.head;\r\n    }\r\n    else {\r\n        enclosing = new List(typ, new List());\r\n    }\r\n    if (val == null) {\r\n        if (!isNullable(typ)) {\r\n            invalidate(val, typ, path);\r\n        }\r\n        return val;\r\n    }\r\n    else if (typeof typ === \"string\") {\r\n        if ((typ === \"boolean\" || typ === \"number\" || typ === \"string\") && (typeof val !== typ)) {\r\n            invalidate(val, typ, path);\r\n        }\r\n        return val;\r\n    }\r\n    else if (typ instanceof NonDeclaredType) {\r\n        switch (typ.kind) {\r\n            case \"Unit\":\r\n                return null;\r\n            case \"Option\":\r\n                return inflate(val, new List(typ.generics, enclosing), path);\r\n            case \"Array\":\r\n                if (typ.definition != null) {\r\n                    return new typ.definition(val);\r\n                }\r\n                else {\r\n                    return inflateArray(val, new List(typ.generics, enclosing), path);\r\n                }\r\n            case \"Tuple\":\r\n                return typ.generics.map(function (x, i) {\r\n                    return inflate(val[i], new List(x, enclosing), combine(path, i));\r\n                });\r\n            case \"GenericParam\":\r\n                return inflate(val, resolveGeneric(typ.definition, enclosing.tail), path);\r\n            case \"GenericType\":\r\n                var def = typ.definition;\r\n                if (def === List) {\r\n                    return Array.isArray(val)\r\n                        ? listOfArray(inflateArray(val, resolveGeneric(0, enclosing), path))\r\n                        : inflateList(val, resolveGeneric(0, enclosing), path);\r\n                }\r\n                if (def === FableSet) {\r\n                    return setCreate(inflateArray(val, resolveGeneric(0, enclosing), path));\r\n                }\r\n                if (def === Set) {\r\n                    return new Set(inflateArray(val, resolveGeneric(0, enclosing), path));\r\n                }\r\n                if (def === FableMap) {\r\n                    return mapCreate(inflateMap(val, resolveGeneric(0, enclosing), resolveGeneric(1, enclosing), path));\r\n                }\r\n                if (def === Map) {\r\n                    return new Map(inflateMap(val, resolveGeneric(0, enclosing), resolveGeneric(1, enclosing), path));\r\n                }\r\n                return inflate(val, new List(typ.definition, enclosing), path);\r\n            default:\r\n                return val;\r\n        }\r\n    }\r\n    else if (typeof typ === \"function\") {\r\n        if (typ === Date) {\r\n            return dateParse(val);\r\n        }\r\n        var info = typeof typ.prototype[FableSymbol.reflection] === \"function\" ? typ.prototype[FableSymbol.reflection]() : {};\r\n        if (info.cases) {\r\n            var uCase = void 0, uFields = [];\r\n            if (typeof val === \"string\") {\r\n                uCase = val;\r\n            }\r\n            else if (typeof val.Case === \"string\" && Array.isArray(val.Fields)) {\r\n                uCase = val.Case;\r\n                uFields = val.Fields;\r\n            }\r\n            else {\r\n                var caseName = Object.getOwnPropertyNames(val)[0];\r\n                var fieldTypes = info.cases[caseName];\r\n                if (Array.isArray(fieldTypes)) {\r\n                    var fields = fieldTypes.length > 1 ? val[caseName] : [val[caseName]];\r\n                    uCase = caseName;\r\n                    path = combine(path, caseName);\r\n                    for (var i = 0; i < fieldTypes.length; i++) {\r\n                        uFields.push(inflate(fields[i], new List(fieldTypes[i], enclosing), combine(path, i)));\r\n                    }\r\n                }\r\n            }\r\n            if (uCase in info.cases === false) {\r\n                invalidate(val, typ, path);\r\n            }\r\n            return new typ(uCase, uFields);\r\n        }\r\n        if (info.properties) {\r\n            var newObj = new typ();\r\n            var properties = info.properties;\r\n            var ks = Object.getOwnPropertyNames(properties);\r\n            for (var i = 0; i < ks.length; i++) {\r\n                var k = ks[i];\r\n                newObj[k] = inflate(val[k], new List(properties[k], enclosing), combine(path, k));\r\n            }\r\n            return newObj;\r\n        }\r\n        return val;\r\n    }\r\n    throw new Error(\"Unexpected type when deserializing JSON: \" + typ);\r\n}\r\nfunction inflatePublic(val, genArgs) {\r\n    return inflate(val, genArgs ? genArgs.T : null, \"\");\r\n}\r\nexport { inflatePublic as inflate };\r\nexport function ofJson(json, genArgs) {\r\n    return inflate(JSON.parse(json), genArgs ? genArgs.T : null, \"\");\r\n}\r\nexport function toJsonWithTypeInfo(o) {\r\n    return JSON.stringify(o, function (k, v) {\r\n        if (ArrayBuffer.isView(v)) {\r\n            return Array.from(v);\r\n        }\r\n        else if (v != null && typeof v === \"object\") {\r\n            var typeName = typeof v[FableSymbol.reflection] === \"function\" ? v[FableSymbol.reflection]().type : null;\r\n            if (v instanceof List || v instanceof FableSet || v instanceof Set) {\r\n                return {\r\n                    $type: typeName || \"System.Collections.Generic.HashSet\",\r\n                    $values: Array.from(v)\r\n                };\r\n            }\r\n            else if (v instanceof FableMap || v instanceof Map) {\r\n                return fold(function (o, kv) { o[kv[0]] = kv[1]; return o; }, { $type: typeName || \"System.Collections.Generic.Dictionary\" }, v);\r\n            }\r\n            else if (typeName) {\r\n                if (hasInterface(v, \"FSharpUnion\") || hasInterface(v, \"FSharpRecord\")) {\r\n                    return Object.assign({ $type: typeName }, v);\r\n                }\r\n                else {\r\n                    var proto = Object.getPrototypeOf(v), props = Object.getOwnPropertyNames(proto), o_1 = { $type: typeName };\r\n                    for (var i = 0; i < props.length; i++) {\r\n                        var prop = Object.getOwnPropertyDescriptor(proto, props[i]);\r\n                        if (prop.get)\r\n                            o_1[props[i]] = prop.get.apply(v);\r\n                    }\r\n                    return o_1;\r\n                }\r\n            }\r\n        }\r\n        return v;\r\n    });\r\n}\r\nexport function ofJsonWithTypeInfo(json, genArgs) {\r\n    var parsed = JSON.parse(json, function (k, v) {\r\n        if (v == null)\r\n            return v;\r\n        else if (typeof v === \"object\" && typeof v.$type === \"string\") {\r\n            var type = v.$type.replace('+', '.'), i = type.indexOf('`');\r\n            if (i > -1) {\r\n                type = type.substr(0, i);\r\n            }\r\n            else {\r\n                i = type.indexOf(',');\r\n                type = i > -1 ? type.substr(0, i) : type;\r\n            }\r\n            if (type === \"System.Collections.Generic.List\" || (type.indexOf(\"[]\") === type.length - 2)) {\r\n                return v.$values;\r\n            }\r\n            if (type === \"Microsoft.FSharp.Collections.FSharpList\") {\r\n                return listOfArray(v.$values);\r\n            }\r\n            else if (type == \"Microsoft.FSharp.Collections.FSharpSet\") {\r\n                return setCreate(v.$values);\r\n            }\r\n            else if (type == \"System.Collections.Generic.HashSet\") {\r\n                return new Set(v.$values);\r\n            }\r\n            else if (type == \"Microsoft.FSharp.Collections.FSharpMap\") {\r\n                delete v.$type;\r\n                return mapCreate(Object.getOwnPropertyNames(v)\r\n                    .map(function (k) { return [k, v[k]]; }));\r\n            }\r\n            else if (type == \"System.Collections.Generic.Dictionary\") {\r\n                delete v.$type;\r\n                return new Map(Object.getOwnPropertyNames(v)\r\n                    .map(function (k) { return [k, v[k]]; }));\r\n            }\r\n            else {\r\n                var T = getType(type);\r\n                if (T) {\r\n                    delete v.$type;\r\n                    return Object.assign(new T(), v);\r\n                }\r\n            }\r\n        }\r\n        else if (/^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(?:\\.\\d+)?(?:[+-]\\d{2}:\\d{2}|Z)$/.test(v))\r\n            return dateParse(v);\r\n        else\r\n            return v;\r\n    });\r\n    var expected = genArgs ? genArgs.T : null;\r\n    if (parsed != null && typeof expected === \"function\"\r\n        && !(parsed instanceof getDefinition(expected))) {\r\n        throw new Error(\"JSON is not of type \" + expected.name + \": \" + json);\r\n    }\r\n    return parsed;\r\n}\r\n","namespace Test\n\nopen Common.State\nopen Common.Error\nopen Execute.GetStates\nopen Parse\nopen Interpret\nopen Fable.Core\nopen Fable.Import\nopen FsHtml\nopen Fable.Core.JsInterop\n\nmodule Tester = \n    type Test = \n        {Input:string; Output:int[]}\n            \n    type Tests = \n        Tests of Test[]\n\n    let mutable state = initStateVisual\n    let nState code = newStateAll state code\n    let boolString b = \n        match b with\n        | true -> sprintf \"%i\" 1\n        | false -> sprintf \"%i\" 0\n    \n    let boolInt b = \n        match b with\n        | true -> 1\n        | false -> 0\n    \n    let stateArray state = \n        let getReg state i = \n            match i with\n            | a when a <= 15 -> (readReg i state)\n            | 16 -> boolInt (readNFlag state)\n            | 17 -> boolInt (readZFlag state)\n            | 18 -> boolInt (readCFlag state)\n            | 19 -> boolInt (readVFlag state)\n            | _ -> -1\n\n        let testArray:int[] = Array.map (getReg state) [|0..19|]\n        testArray\n\n    let outputString code = \n        match (nState code) with\n            | Ok(i,s) -> (stateArray s)\n            | Err(i,msg) -> [|0|]\n\n    let runTest test = \n        match test with\n        | {Input=i;Output=o} -> (=) o (outputString i)\n\n    let printTest json = \n        let getString test = match test with\n                                | {Input=i;Output=o} -> (sprintf \"Correct: %A; Incorrect: %A\" (outputString i) o)\n\n        match json with\n        |  Tests test -> test |> Array.map(fun test -> getString test)\n\n    let runTests json = \n        let correct = match json with\n                        | Tests test -> \n                            test \n                            |> Array.map(fun test -> runTest test) \n                            |> Array.reduce (fun acc elem -> acc && elem)\n        \n        if correct \n        then \"PASSED FRONT END TEST\" \n        else (sprintf \"FAILED// %A\" (printTest json))","module Main\nopen Common.State\nopen Common.Error\nopen Execute.GetStates\nopen Parse\nopen Interpret\nopen Fable.Core\nopen Fable.Import\nopen FsHtml\nopen Fable.Core.JsInterop\nopen Test.Tester\n\n[<EntryPoint>]    \nlet main args = \n    let regs = Browser.document.getElementById \"regs\"\n    let errorBox = Browser.document.getElementById \"errorBox\"\n    let compileAllBtn = Browser.document.getElementById \"compileAllBtn\"\n    let compileNextLineBtn = Browser.document.getElementById \"compileNextLineBtn\"\n    let resetBtn = Browser.document.getElementById \"resetBtn\"\n    let saveCodeMirror: JsFunc1<_,string> = import \"saveCodeMirror\" \"../js/helper_functions.js\"\n    let initializeCodeMirror: JsFunc0<_> = import \"initializeCodeMirror\" \"../js/helper_functions.js\"\n    let highlightLine: JsFunc3<int,_,int,_> = import \"highlightLine\" \"../js/helper_functions.js\"\n    let changeCMTheme: JsFunc0<_> = import \"changeCMTheme\" \"../js/helper_functions.js\"\n    let clearAllLines: JsFunc1<_,_> = import \"clearAllLines\" \"../js/helper_functions.js\"\n    let getJSON: JsFunc0<_> = import \"getJSON\" \"../js/helper_functions.js\"\n    let cmEditor = initializeCodeMirror.Invoke()\n    let mutable state = initStateVisual\n\n    let rec toBinary (value: uint32)=\n        if value < 2u then\n            value.ToString()\n        else\n            let divisor = value/2u\n            let remainder = (value % 2u).ToString()\n            toBinary(divisor) + remainder\n\n    let getRegisterTable valid regState = \n        div [\n            table [\n                    \"class\"%=\"table table-striped table-condensed\"                \n                    thead [                    \n                        tr [\n                            th %(\"Register\")\n                            th %(\"Hex\")\n                            th %(\"Bin\")\n                            th %(\"Dec (sig)\")\n                            th %(\"Dec (unsig)\")\n\n                        ]\n                    ]\n                    tbody [ \n                    \"class\"%= (match valid with\n                                | false -> \"red\"\n                                | true -> \"black\")\n                    div [\n                        for i in 0..15 ->\n                            tr [\n                                th %(sprintf \"R%A\" i)\n                                th ( match valid with\n                                        | false -> %(sprintf \"X\")\n                                        | true -> %(sprintf \"%08X\" (readReg i regState))) \n                                th ( match valid with\n                                        | false -> %(sprintf \"X\")\n                                        | true -> %(regState |> readReg i |> uint32 |> toBinary)) \n                                th ( match valid with\n                                        | false -> %(sprintf \"X\")\n                                        | true -> %(sprintf \"%i\" (readReg i regState)))\n                                th ( match valid with\n                                        | false -> %(sprintf \"X\")\n                                        | true -> %(sprintf \"%i\" (regState |> readReg i |> uint32)))  \n                            ]\n\n                        ]\n                    ]\n                ]\n            br []\n            table [\n                    \"class\"%=\"table table-striped table-condensed\"   \n                    thead [                    \n                            tr [\n                                th %(\"Flag\")\n                                th %(\"Value\")\n                            ]\n                        ]\n                    tbody [ \n                    \"class\"%= (match valid with\n                                | false -> \"red\"\n                                | true -> \"black\")\n                    div [\n                            tr [\n                                th %(sprintf \"N\")\n                                th ( match valid with\n                                        | false -> %(sprintf \"X\")\n                                        | true -> %(sprintf \"%A\" (readNFlag regState))) \n                            ]\n                            tr [\n                                th %(sprintf \"Z\")\n                                th ( match valid with\n                                        | false -> %(sprintf \"X\")\n                                        | true -> %(sprintf \"%A\" (readZFlag regState))) \n                            ]\n                            tr [\n                                th %(sprintf \"C\")\n                                th ( match valid with\n                                        | false -> %(sprintf \"X\")\n                                        | true -> %(sprintf \"%A\" (readCFlag regState))) \n                            ]\n                            tr [\n                                th %(sprintf \"V\")\n                                th ( match valid with\n                                        | false -> %(sprintf \"X\")\n                                        | true -> %(sprintf \"%A\" (readVFlag regState))) \n                            ]\n                    ]\n                ]\n            ]\n        ]\n\n            \n    let compileAll () = \n        clearAllLines.Invoke(cmEditor)\n        let code = saveCodeMirror.Invoke(cmEditor)\n        let state = initStateVisual\n        let nState = newStateAll state code\n\n        let registerString = \n            match nState with\n            | Ok(i,s) -> (getRegisterTable true s) |> Html.toString\n            | Err(i,msg) -> (getRegisterTable false initState) |> Html.toString\n\n        let errorString = \n            match nState with\n            | Ok(i,s) -> sprintf \"Ran %i lines\" i\n            | Err(i,msg) -> sprintf \"ERROR ON LINE %i\\t %s\" i msg\n        \n        match nState with\n            | Ok(i,s) -> ()\n            | Err(i,msg) -> highlightLine.Invoke(i,cmEditor,1)\n\n        regs.innerHTML <- registerString \n        errorBox.innerHTML <- errorString\n    \n    let compileNextLine () = \n        clearAllLines.Invoke(cmEditor)\n        let code = saveCodeMirror.Invoke(cmEditor)\n        let nState = newStateSingle state code\n\n        let registerString = \n            match nState with\n            | Ok(i,s) -> (getRegisterTable true s) |> Html.toString\n            | Err(i,msg) -> (getRegisterTable false initState) |> Html.toString\n\n        let errorString = \n            match nState with\n            | Ok(i,s) -> sprintf \"Ran line %i\" i\n            | Err(i,msg) -> sprintf \"ERROR ON LINE %i\\t %s\" i msg\n        \n        state <- \n            match nState with\n            | Ok(i,s) -> s\n            | Err(i,msg) -> initStateVisual\n        \n        match nState with\n            | Ok(i,s) -> highlightLine.Invoke(i,cmEditor,2)\n            | Err(i,msg) -> highlightLine.Invoke(i,cmEditor,1)\n\n        regs.innerHTML <- registerString \n        errorBox.innerHTML <- errorString\n    \n    let resetCompiler () =\n        clearAllLines.Invoke(cmEditor)\n        state <- initStateVisual\n        errorBox.innerHTML <- \"\"\n        regs.innerHTML <- ((getRegisterTable true state) |> Html.toString)\n\n    let jsonString = getJSON.Invoke()\n    let json = ofJson<Tests> jsonString\n    runTests json |> printf \"%A\"\n\n    compileAllBtn.addEventListener_click(fun _ -> compileAll () ; null)\n    compileNextLineBtn.addEventListener_click(fun _ -> compileNextLine () ; null)\n    resetBtn.addEventListener_click(fun _ -> resetCompiler () ; null)\n    resetCompiler ()\n    0"],"names":["FSymbol","foldBack","tryFind","fold","map","listOfArray","seqCompareWith","seqMap","append","seqFold","reverse","filter","partition","create","split","initialize","replicate","toString_1","tree_height","tree_mk","tree_rebalance","tree_add","tree_mem","tree_collapseLHS","tree_mkIterator","tree_moveNext","tree_mkFromEnumerator","tree_ofSeq","from","FableSymbol","setCreate","mapCreate","dateParse"],"mappings":"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"}